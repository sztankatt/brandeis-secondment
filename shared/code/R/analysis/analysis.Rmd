--- 
title: "m6a analysis"
author: "tsztank"
date: "`r format(Sys.time(), '%d/%B/%Y')`"
output: 
 html_document:
  toc: true
---

```{r knitr_options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  cache = T,
  autodep = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = NA,
  cache.path = 'cache/',
  fig.path = 'figures/',
  knitr.table.format = 'markdown')
```

```{r load_libraries, echo = F, cache = F}
library(plyr)
library(tidyverse)
library(biomaRt)
library(magrittr)
library(yaml)
library(readr)
library(cowplot)
library(wesanderson)
library(GGally)
library(DESeq2)
library(tximport)
library(kableExtra)
library(metaseqR)
library(topGO)
```

```{r load_functions, echo = F, cache = F}
root_dir <- '../../../../'
source(paste0(root_dir, 'shared/code/R/readStarLog.R'))
source(paste0(root_dir, 'shared/code/R/calculateEnrichment.R'))
source(paste0(root_dir, 'shared/code/R/getGOData.R'))

# set the default title spacing for plots
theme_update(plot.title = element_text(hjust = 0),
			 strip.text.x = element_text(margin = margin(c(3,3,3,3))),
			 strip.text.y = element_text(margin = margin(c(3,3,3,3))))

michela_m6a_root <- paste0(root_dir, 'michela/m6a/')

options(knitr.table.format = "markdown")
```

```{r get_gene_name_id_map, echo = F}
options(knitr.table.format = "markdown")

ensembl = useMart('ensembl', dataset = 'dmelanogaster_gene_ensembl')

txs <- ensembl %>%
	getBM(
		  attributes = c('ensembl_gene_id',
						 'ensembl_transcript_id',
						 'external_gene_name',
						 'external_transcript_name',
						 'start_position', 
						 'end_position', 
						 'strand',
						 'gene_biotype'),
		  mart = .) %>%
	as_tibble

colnames(txs) <- c('gene_id', 'tx_id', 'gene_name', 'tx_name', 'gene_start', 'gene_end', 'strand', 'gene_biotype')

txs <- txs %>% mutate(gene_length = gene_end - gene_start)

genes <- txs %>%
	dplyr::select(-tx_id, -tx_name) %>%
	unique %>%
	mutate(gene_length = gene_end - gene_start)

m_rnas <- genes %>%
	filter(gene_biotype == 'protein_coding')

go_terms <- ensembl %>%
	getBM(
		  attributes = c('ensembl_gene_id',
						 'go_id'),
		  mart = .) %>%
	as_tibble %>%
	dplyr::rename(gene_id = ensembl_gene_id)

gene_id2go <- go_terms %>%
	dlply(.(gene_id), function(df){ df$go_id})

gene_features <- ensembl %>%
	getBM(
		  attributes = c('ensembl_gene_id',
						 'ensembl_transcript_id',
						 'strand',
						 'transcript_start',
						 'transcript_end',
						 '5_utr_start',
						 '5_utr_end',
						 '3_utr_start',
						 '3_utr_end',
						 'cds_length'),
		  mart = .) %>%
	as_tibble %>%
	dplyr::rename(gene_id = ensembl_gene_id)

colnames(gene_features) <- c('gene_id', 'tx_id','strand', 'tx_start', 'tx_end', 'fivep_start', 'fivep_end', 'threep_start', 'threep_end', 'cds_length')

tx2gene <- txs %>%
	dplyr::select(gene_name, gene_id, tx_id)
```

```{r load_sample_specification, echo = F}
config = read_yaml(paste0(michela_m6a_root, 'config.yaml'))
samples <- config$samples %>% names
```

```{r parse_star_logfiles, echo = F}
star_log <- samples %>%
	ldply(function(sample){
		readStarLog(paste0(michela_m6a_root,'data/mapping/', sample, '.Log.final.out')) %>% data.frame(sample = sample)
	}) %>%
	as_tibble %>%
	separate(sample, into = c('condition', 'replicate'), extra = 'drop') %>%
	group_by(replicate) %>%
	mutate(read_ratio = uniq_reads / sum(uniq_reads))

star_log %>% kable(format.args = list(decimal.mark = ',', big.mark = " ")) %>% kable_styling(c('striped'), full_width = F, position = "left")
```


ESAT (ref) is a counting toolkit designed for short 3' or 5' libraries. As a check, we also mapped the reads with STAR and then counted the reads on the gene level with ESAT, and correlated the results with counts coming from kallisto+tximport

## Sanity checks

The if we plot the counts and tpm-s (transcript per million) on a log-x scale, we observe a normal distribution which is expected. Also, the mean values of tpm-s are comparable, so it seems there is not big difference between the libraries of the 3 conditions sequenced.

```{r import_esat_counts, echo = F}
esat_dir = paste0(michela_m6a_root, 'data/esat/')
esat_counts <- samples %>%
	# create a dataframe out of counts
	data.frame(sample = .) %>%
	# create a filename column, and load dataframes as a list
	mutate(filename = paste0(esat_dir, sample, '.gene.txt'), 
		   file_contents = map(filename, ~read_table2(.))) %>%
	# expand the lists
	unnest() %>%
	# create tibble
	as_tibble %>%
	# rename columns
	transmute(sample = sample,
			  gene_id = Symbol,
			  count = Exp1) %>%
	# fill non detected genes in each sample with zeros
	spread(sample, count, fill = 0) %>%
	# gather back
	gather('sample', 'count', samples) %>%
	separate(sample, into = c('condition', 'replicate'), extra = 'drop') %>%
	inner_join(genes, by = 'gene_id') %>%
	# we need to group before tmp counting...
	group_by(condition, replicate) %>%
	# look at only mRNAs for now
	filter(gene_biotype == 'protein_coding') %>%
	mutate(tpm = count / gene_length,
		   tpm = tpm / sum(tpm) * 1e6)
```

```{r plot_histogram_tpm, echo =F}
esat_counts %>%
	ggplot(aes(tpm, fill = condition)) +
	geom_density(alpha = 0.8) +
	scale_x_log10() +
	scale_fill_manual(values=wes_palette(n=3, name="GrandBudapest1")) +
	ggtitle('TPM comparison between conditions')
```

```{r plot_histogram_counts, echo =F}
esat_counts %>%
	ggplot(aes(count, fill = condition)) +
	geom_density(alpha = 0.8) +
	scale_x_log10() +
	scale_fill_manual(values=wes_palette(n=3, name="GrandBudapest1")) +
	facet_grid(condition~replicate) +
	theme(axis.text.x = element_text(angle = 45, hjust =1)) +
	ggtitle('Estimated counts of each run')
```

### PCA analysis

```{r create_dds_from_counts, echo = F}
sample_metadata <- tibble(sample = samples) %>%
	separate(sample, into = c('condition', 'replicate'), extra = 'drop') %>%
	unite('sample', condition, replicate, remove =F) %>%
	mutate(condition = factor(condition, levels = c('input', 'igg', 'ip')),
		   replicate = factor(replicate, levels = c('1','2','3'))) %>%
	# sort tibble by factor
	arrange(condition)

count_matrix <- esat_counts %>%
	unite('sample', c('condition', 'replicate')) %>%
	dplyr::select(sample, count, gene_name) %>%
	# spread values, fill with 0, as NA here means ND = 0 count
	spread(sample, count, fill = 0) %>%
	{
		genes <- .$gene_name
		mx <- dplyr::select(., -gene_name) %>%
			as.matrix

		rownames(mx) <- genes

		mx
	}

# get the columns into the right order
count_matrix <- count_matrix[,sample_metadata$sample]

m6a_dds <- DESeqDataSetFromMatrix(countData = count_matrix,
							  colData = sample_metadata %>% {data.frame(., row.names = .$sample)},
							  design = ~ replicate + condition )
```

```{r prepare_deseq, echo = F}
m6a_dds <- DESeq(m6a_dds)

ip_vs_input.res <- results(m6a_dds,name = 'condition_ip_vs_input', alpha = 0.01)
ip_vs_input.resLFC <- lfcShrink(m6a_dds, res = ip_vs_input.res, coef = 'condition_ip_vs_input', type = 'apeglm') %>%
	as.data.frame %>%
	rownames_to_column(var = 'gene_name') %>%
	as_tibble
```


From the below PCA plot we can clearly see, that replicate 3 is an outlier, it is therefore probably better to not take it into account.

```{r pca_analysis, echo = F}
vsd <- vst(m6a_dds, blind=FALSE)
pca <- DESeq2::plotPCA(vsd, intgroup=c('condition', 'replicate'), returnData=T) %>%
	as_tibble

pca %>%
	# modify factor level to have consistent colors
	mutate(condition = factor(condition, levels = c('igg', 'input', 'ip'))) %>%
	ggplot(aes(PC1, PC2, colour = condition, shape = replicate)) + 
	geom_point(size = 4) +
	scale_colour_manual(values=wes_palette(n=3, name="GrandBudapest1"))

```

### Looking at genes of interest

First lets look at 3 genes: Clk, tim and vri.

It seems that for these 3 genes, igg\_3 is an outlier.

```{r plot_genes_of_interest, echo = F, fig.width = 10, fig.height = 5}
genes_of_interest <- c('vri', 'Clk', 'tim')

plot_genes <- function(tpm, genes, x_lab, metric = 'tpm'){
	tpm %>%
		filter(gene_name %in% genes) %>%
		ggplot(aes_string(x_lab, metric, colour = 'condition', shape = 'replicate')) +
			geom_point(size = 4, position = position_dodge(width=0.3)) +
			scale_colour_manual(values=wes_palette(n=3, name="GrandBudapest1")) +
			scale_y_log10()
}

pl1 <- plot_genes(esat_counts, genes_of_interest, x_lab = 'gene_name', metric = 'tpm')
pl2 <- plot_genes(esat_counts, genes_of_interest, x_lab = 'gene_name', metric = 'count')

plot_grid(pl1, pl2, ncol = 2)
```

Lets look at Mbl separately. Here we again can observe that 3 is an outlier compared to others.

```{r plot_mbl_tpm, echo = F}
plot_genes(esat_counts, c('mbl'), x_lab = 'gene_name', metric = 'tpm')
```

### Correlation between replicates

Next to check any differences between our ip's we looked at correlations between any two ip samples. Overall correlations on the count level are quite good, with ip\_3 being much deeper than the other two samples.

The correlations in the TPM space are a bit worse for ip\_1 vs ip\_3 and ip\_2 vs ip\_3, but still okay.

If we downsample ip\_3 to 9 million reads (so that the sample sizes are preferable), the correlations do not change which is the expected behaviour.


```{r correlation_function, echo = F}
get_cor_plot <- function(data, sx, sy, quant_type = 'count'){
	dat <- data %>%
		unite('run', condition, replicate) %>%
		dplyr::select(gene_id, run, quant_type) %>%
		spread(run, quant_type, fill = 0)

	r <- cor(dat[[sx]], dat[[sy]])

	pl <- dat %>%
		# convert quant_type to log for visualization
		gather('run', 'quant_type', -gene_id) %>%
		mutate(quant_type = log10(quant_type)) %>%
		spread(run, quant_type) %>%
		ggplot(aes_string(x=sx, y=sy)) +
			geom_point(alpha = 0.7, size = 0.5) +
			coord_fixed() +
			labs(y = paste0('log10(', sy, '_', quant_type, ')'),
				 x = paste0('log10(', sx, '_', quant_type, ')'))

	pl <- pl + annotate("text", Inf, -Inf, label = paste0('R = ', round(r, 3)), hjust = 1, vjust = -5)

	if(quant_type == 'count'){
		pl <- pl +
			scale_y_continuous(limits = c(0,6)) +
			scale_x_continuous(limits = c(0,6))
	} else {
		pl <- pl +
			scale_y_continuous(limits = c(-5, 5)) +
			scale_x_continuous(limits = c(-5, 5))
	}

	pl
}
```

##### Raw counts

```{r plot_counts_correlations, echo = F, fig.height = 3, fig.width = 10}
plot_grid(get_cor_plot(esat_counts, 'ip_1', 'ip_3'),
		  get_cor_plot(esat_counts, 'ip_2', 'ip_3'),
		  get_cor_plot(esat_counts, 'ip_1', 'ip_2'),
		  ncol = 3)

```

##### TPMs

```{r plot_tpm_correlations, echo = F, fig.height = 3, fig.width = 10}
ttl <- ggdraw()  + draw_label('Correlation between m6A replicates is high', fontface = 'bold')
p <- plot_grid(get_cor_plot(esat_counts, 'ip_3', 'ip_1', quant_type = 'tpm'),
		  get_cor_plot(esat_counts, 'ip_3', 'ip_2', quant_type = 'tpm'),
		  get_cor_plot(esat_counts, 'ip_1', 'ip_2', quant_type = 'tpm'),
		  ncol = 3)
plot_grid(ttl, p, ncol = 1, rel_heights = c(0.1, 1))
```

#### Downsampled correlations

```{r downsample_ip_values, echo = F, eval = F}
ip_counts <- esat_counts %>%
	dplyr::select(condition, replicate, gene_name, count) %>%
	filter(condition == 'ip') %>%
	unite('sample', condition, replicate) %>%
	spread(sample, count)

ip_counts <- data.frame(ip_counts[,-1], row.names = ip_counts$gene_name)

downsampled_ip_counts <- ip_counts %>%
	downsample.counts(seed = 10) %>%
	rownames_to_column(var = 'gene_name') %>%
	as_tibble
```

```{r downsample_ip_3, echo =F}
ip_3_counts <- esat_counts %>%
	filter(condition == 'ip', replicate == 3) %>%
	dplyr::select(gene_name, count) %>% {
		rep(.$gene_name, .$count)
	}

ip_3_downsampled <- ip_3_counts %>%
	sample(size = 9*1e6) %>%
	table %>%
	as.data.frame

colnames(ip_3_downsampled) <- c('gene_name', 'ip_3')

ip_3_downsampled <- ip_3_downsampled %>% 
	mutate(gene_name = as.character(gene_name))
```


```{r merge_downsampled_values_back, echo = F, eval = T}
# calculate downsampled counts, as follows: treat each read independently,
# then draw 9 million reads out of 42 million, without replacement, with uniform
# probability
# 
# first drop tmp as it will be recalculated
downsampled_counts <- esat_counts %>%
	dplyr::select(-tpm) %>%
	# remove ip samples 
	filter(condition != 'ip' | replicate != '3') %>%
	# unite columns into samples
	unite('sample', condition, replicate) %>%
	# spread the values before we can inner join with downsampled values
	spread(sample, count) %>%
	# left join so that we get all the values right, replaced with NA's
	left_join(ip_3_downsampled, by = 'gene_name') %>%
	# replace NA's with 0's
	mutate(ip_3 = ifelse(is.na(ip_3), 0, ip_3)) %>%
	#gather columns back
	gather('sample', 'count', igg_1:ip_3) %>%
	separate(sample, into = c('condition', 'replicate')) %>%
	group_by(condition, replicate) %>%
	# recalculate tpm's
	mutate(tpm = count / gene_length,
		   tpm = tpm / sum(tpm) * 1e6)


# perform a test here
tpms <- downsampled_counts %>%
	dplyr::select(gene_name, tpm, count, replicate, condition) %>%
	inner_join(esat_counts %>%
			   	dplyr::select(replicate, condition, gene_name, tpm, count),
				by=c('replicate', 'condition', 'gene_name'))
```

##### Counts

```{r plot_downsampled_count_correlations, echo = F, fig.height = 3, fig.width = 10}
plot_grid(get_cor_plot(downsampled_counts, 'ip_3', 'ip_1'),
		  get_cor_plot(downsampled_counts, 'ip_3', 'ip_2'),
		  get_cor_plot(downsampled_counts, 'ip_1', 'ip_2'),
		  ncol = 3)
```

##### TPM's

```{r plot_downsampled_tpm_correlations, echo = F, fig.height = 3, fig.width = 10}
plot_grid(get_cor_plot(downsampled_counts, 'ip_3', 'ip_1', quant_type = 'tpm'),
		  get_cor_plot(downsampled_counts, 'ip_3', 'ip_2', quant_type = 'tpm'),
		  get_cor_plot(downsampled_counts, 'ip_1', 'ip_2', quant_type = 'tpm'),
		  ncol = 3)
```

## Identify methylated candidate

### Enrichment between pull-downs and input

First we look at enrichments between our pull-downs and the input values, to identify genes which are bound to m6A or igg (negative control). Lets first compare if we see any differences between ip and igg.

#### Enrichment of ip vs in igg

```{r per_sample_enrichment, echo = F}
# calculate ratios of 
enrichment_data <- esat_counts %>%
	calculateEnrichment(conditions = c('igg', 'ip'))
```

```{r create_big_enrichment_table, echo = F}
big_table <- enrichment_data %>%
	unite('sample', pull_down_condition, replicate) %>%
	dplyr::select(gene_name, sample, tpm_enrichment) %>%
	mutate(sample = paste0(sample, '_enrichment')) %>%
	spread(sample, tpm_enrichment)

# append counts
big_table <- big_table %>%
	inner_join(esat_counts %>%
		 	unite('sample', condition, replicate) %>%
			dplyr::select(gene_name, sample, count) %>%
			#rename sample's before spread
			mutate(sample = paste0(sample, '_count')) %>%
			spread(sample, count),
		by = 'gene_name')

big_table <- big_table %>%
	inner_join(esat_counts %>%
				   unite('sample', condition, replicate) %>%
				   dplyr::select(gene_name, sample, tpm) %>%
				   # rename sample before spread
				   mutate(sample = paste0(sample, '_tpm')) %>%
				   spread(sample, tpm, fill = 0),
			   by = 'gene_name')

write_excel_csv(big_table, paste0(michela_m6a_root, 'data/expression_table.csv'))
```

Next we checked if we indeed get an enrichment in ip/input, versus igg/input.
This is the case, if we look at the distribution of median enrichment ip/input vs igg/input: we get more values enriched in the ip/input, and the distribution has a higher mean.

```{r calculate_enrichment_medians, echo = F}
# calculate the median enrichment for both ip/input and igg/input
enrichment_medians <- enrichment_data %>%
	mutate(condition = pull_down_condition) %>%
	group_by(gene_name, condition) %>%
	summarise(median_enrichment = median(tpm_enrichment)) %>%
	filter(median_enrichment %>% is.finite)
```

```{r plot_density_of_enrichment_hist, echo = F}
# calculate mean of each distribution, for later visualisation
mu <- enrichment_medians %>%
	ungroup %>%
	group_by(condition) %>%
	summarise(grp.mean = mean(median_enrichment))

wpl <- wes_palette(n=3, name = 'GrandBudapest1')
color_values <- c('igg' = wpl[1],
				  'input' = wpl[2],
				  'ip' = wpl[3])

# visualise enrichment, plotting also the means
enrichment_medians %>%
	#mutate(condition = factor(condition, levels = c('igg', 'input', 'ip'))) %>%	
	ggplot(aes(median_enrichment, color = condition, fill = condition)) +
		geom_density(alpha = 0.3) +
		geom_vline(data = mu, aes(xintercept = grp.mean, color = condition), size = 1, linetype='dashed') +
		scale_fill_manual(values=color_values) +
		scale_color_manual(values=color_values) +
		scale_x_continuous(breaks = 0:5, limits = c(0, 5.5)) +
		ggtitle('Median enrichment of ip and igg versus input')
```

```{r plot_density_of_enrichment_points, echo = F, eval = F}
enrichment_medians %>%
	spread(condition, median_enrichment) %>%
	ggplot(aes(ip, igg)) +
		geom_point()
```

#### Enrichment between downsampled and normal ip's

```{r compare_enrichment_downsampled_normal, echo = F}
# combine dowsnapled enrichment with normal enrichment. 
# basically this means that the tpm_enrichment will change for ip_3
enrichment_comparison_data <- downsampled_counts %>%
	calculateEnrichment(conditions = c('igg', 'ip')) %>%
	# select only key columns and tpm
	dplyr::select(replicate, gene_name, pull_down_condition, tpm_enrichment) %>%
	inner_join(enrichment_data %>% dplyr::select(-pull_down_tpm),
			   by = c('replicate', 'gene_name', 'pull_down_condition'),
			   # modify suffix for downregulated and normal enrichment
			   suffix = c('.ds', '.normal')) %>%
	group_by(replicate, pull_down_condition) %>%
	mutate(enrichment_diff = abs(tpm_enrichment.normal - tpm_enrichment.ds))
```

```{r plot_enrichment_difference_density, echo = F}
# plot the enrichment comparison as a density function to get distribution differences
# ip 1 and 2 should stay the same, while ip 3 distribution might slightly change
enrichment_comparison_data %>%
	filter(pull_down_condition == 'ip') %>%
	gather('enrichment_type', 'tpm_enrichment', tpm_enrichment.normal, tpm_enrichment.ds) %>%
	mutate(enrichment_type = factor(enrichment_type),
		   enrichment_type = mapvalues(enrichment_type, from = c('tpm_enrichment.normal', 'tpm_enrichment.ds'), to = c('normal', 'ds')),
		   enrichment_type = factor(enrichment_type, levels = c('normal', 'ds')), 
		   tpm_enrichment = log10(tpm_enrichment)) %>% 
	filter(tpm_enrichment %>% is.finite) %>%
	ggplot(aes(tpm_enrichment, fill = replicate)) +
		geom_density(alpha = 0.5) +
		facet_wrap(~enrichment_type, labeller = labeller(enrichment_type = c('ds' = 'Downsampled counts', 'normal' = 'Raw counts'))) +
		xlab('log10(tpm_enrichment)') +
		ggtitle('Enrichment of ip vs input', 'Enrichment of ip/input for all 3 replicates')
```

#### Compare the ranks of the enrichment

From the plot above it is clear that ip\_3 is a bit off, as compared to the other two replicates. In order to see if the distributions are similar, we first converted the TPM enrichment values (ip/input) into a rank table, then tested whether the ranks are similar between the conditions with a Kruskal-Wallis test.

```{r compute_enrichment_ranks, echo = F}
enrichment_ranks <- enrichment_data %>%
	# select only ip
	filter(pull_down_condition == 'ip') %>%
	# first filter the data according to input count and pull down tpm
	filter(input_count > 4,  pull_down_tpm > 0.1) %>%
	# prepend ip to each replicate
	mutate(replicate = paste0(pull_down_condition, '_', replicate)) %>%
	# drop some variables
	dplyr::select(-pull_down_tpm, -input, -input_count) %>%
	# spread the tpm enrichment values so that we can filter each which is non finite
	spread(replicate, tpm_enrichment) %>%
	filter(is.finite(ip_1), is.finite(ip_2), is.finite(ip_3)) %>%
	gather('replicate', 'tpm', ip_1:ip_3) %>%
	group_by(replicate) %>%
	# calculate rank: this will be in the opposite order, with rank 1 being the smallest enrichment
	mutate(rank = min_rank(tpm)) %>%
	# convert it correct rank order
	mutate(rank = max(rank) - rank) %>%
	# drop tpm before spreading the data into 3 columns
	dplyr::select(-tpm) %>%
	spread(replicate, rank)
```

The pairwise results are below. It can be seen, that differences between the distributions cannot be established, as the p-values are big. Which makes the samples directly comparable.

```{r perform_wilcox_tests, echo = F}
get_wilcox_res <- function(data, x, y){
	res <- wilcox.test(data[[x]], data[[y]], alternative = 'two.sided')
	res <- data.frame(p.value = res$p.value, data.name = res$data.name)

	res
}

test_res <- enrichment_ranks %>% {
		rbind(
		  get_wilcox_res(., 'ip_1', 'ip_2'),
		  get_wilcox_res(., 'ip_1', 'ip_3'),
		  get_wilcox_res(., 'ip_3', 'ip_2')
		)
	}

test_res$data.name = c('ip_1 vs ip_2', 'ip_1 vs ip_3', 'ip_3 vs ip_2')

kable(test_res)
```

#### Identify consistently enriched candidates

To identify consistently enriched we first filtered the genes as follows:

- The have at least a TPM of 0.1 in all 3 ip's
- They are enriched in all three ip/input comparisons at least 2-fold

```{r identify_enriched_candidates, echo = F}
filtered_data <- enrichment_data %>%
	# filter out ip with tpm <= 0.1
	filter(pull_down_tpm > 0.1 | pull_down_condition == 'igg') %>%
	# filter genes which have low counts in the input
	filter(input_count > 4) %>%
	# filter NaN, NA, and Inf values
	filter(is.finite(tpm_enrichment)) %>%
	# group by the gene and condition, ie ip or igg
	group_by(gene_name, pull_down_condition) %>%
	summarise(mean_ip_tpm = mean(pull_down_tpm),
			  median_enrichment = median(tpm_enrichment),
			  max_enrichment = max(tpm_enrichment),
			  min_enrichment = min(tpm_enrichment),
			  passing_filter = n())

# preset variables on which we will filter
filter_ip <- list(mean_tpm = 10,
				  median_enrichment = 3)

# get the significant candidates in ip, that is those which are expressed at least TPM > 0.1 in each ip replicate
candidates_ip <- filtered_data %>%
	filter(passing_filter == 3, pull_down_condition == 'ip') %>%
	mutate(sig = mean_ip_tpm > filter_ip$mean_tpm & median_enrichment > filter_ip$median_enrichment)
```

Below we plot the median TPM enrichment of all 3 ip/input values, against the average ip TPM on a log10-scale.
All values presented here are from after filtering.

Values for which the mean TPM is bigger than `r filter_ip$mean_tpm` and they are at least `r filter_ip$median_enrichment`-fold enriched (in the median) are marked in red.

In total there are `r nrow(filter(candidates_ip, sig ==F))` which pass this filter.

```{r plot_m6a_candidatetpm_vs_enrichment, echo = F}
ip_m6a_candidate_plot <- function(m6a_candidate_df, filters, plot_title = ''){
	gene.n <- m6a_candidate_df %>% nrow
	sig.n <- m6a_candidate_df %>% filter(sig == T) %>% nrow

	m6a_candidate_df %>%
		ggplot(aes(mean_ip_tpm, median_enrichment)) +
			# first add lines to show what we color red
			# vertical line
			# geom_segment(aes(x = filters$mean_tpm, y = filters$median_enrichment, xend = filters$mean_tpm, yend = Inf),
			# 			 alpha = 0.7,
			# 			 size = 0.1,
			# 			 linetype = 'dashed',
			# 			 color = 'red') +
			# # horizontal line
			# geom_segment(aes(x = filters$mean_tpm, y = filters$median_enrichment, xend = Inf, yend = filters$median_enrichment),
			# 			 alpha = 0.7,
			# 			 size =0.1,
			# 			 linetype = 'dashed',
			# 			 color = 'red') +
			# annotate("text", Inf, Inf, label = paste0(sig.n, '/',gene.n, ' genes'), hjust = 2, vjust = 15) +
			geom_point(size = 0.8, alpha = 0.7) +
			scale_y_continuous(breaks = 2:10) +
			scale_x_log10(breaks = c(1,10,100,1000,10000)) +
			scale_color_manual(values = c('black', 'red')) +
			annotation_logticks(sides = 'b') +
			labs(y = 'Median TPM enrichment of m6A/input', x = 'Mean of ip TPM\'s') +
			theme(legend.position = 'none') +
			ggtitle(plot_title) 
}

candidates_ip %>%
	ip_m6a_candidate_plot(plot_title = 'Enriched genes ip/input', filters = filter_ip)
```

In total there are `r nrow(filter(candidates_ip, sig == T))`/`r nrow(filter(candidates_ip, sig ==F))` genes which have mean TPM of at least 10, and average enrichment of at least 4.

#### Remove the background coming from igg pull-down

```{r m6a_candidate_igg_background_removal, echo = F}
# define candidate differences: between ip and igg
enrichment_diff <- filtered_data %>%
	ungroup() %>%
	# only get genes which pass the filter, set above 
	filter(passing_filter == 3 | pull_down_condition == 'igg') %>%
	transmute(gene_name = gene_name,
			  condition = pull_down_condition,
			  # select the highest igg enrichment vs lowest ip
			  selected_enrichment = ifelse(condition == 'ip', median_enrichment, median_enrichment)) %>%
	# spread enrichment ratios
	spread(condition, selected_enrichment) %>%
	# calculate the difference between ip and igg
	mutate(enrichment_diff = ip - igg) %>%
	dplyr::rename(median_ip_enrichment = ip,
				  median_igg_enrichment = igg) %>%
	filter(is.finite(enrichment_diff))
```

```{r plot_m6a_candidate_tpm_vs_enrichment_diff_igg, echo = F}
# we plot the same plot as above, but this time only using the genes for which there is a difference between ip and igg enrichment
candidates_ip_diff <- candidates_ip %>%
	# show only candidates, for which ip enrichment is bigger than 0
	filter(gene_name %in% (enrichment_diff %>% filter(enrichment_diff > 2) %$% gene_name))

candidates_ip_diff %>%
	ip_m6a_candidate_plot(plot_title = 'Enriched genes ip/input without igg background', filters = filter_ip)
```

Here in total there are `r nrow(filter(candidates_ip_diff, sig == T))`/`r nrow(filter(candidates_ip_diff, sig ==F))` genes which have mean TPM of at least 10, and average enrichment of at least 4.


#### Comparing enrichment ip vs igg

```{r plot_igg_vs_ip_enrichment, echo = F}
pl_in <- enrichment_diff %>%
	left_join(ip_vs_input.resLFC, by='gene_name') %>%
	mutate(sig = log2FoldChange > 1 & padj < 0.05)

pl_in %>%
	ggplot(aes(median_ip_enrichment, median_igg_enrichment, color = sig)) +
		geom_point(size = 0.7, alpha = 0.5) +
		geom_segment(x = 1, y = 0, xend = 4, yend = 3, linetype = 'dashed', color = 'red') +
		scale_y_continuous(breaks = 0:10, limits = c(0,10), expand = c(0,0)) +
		scale_x_continuous(breaks = 0:10, limits = c(0,10), expand = c(0,0)) +
		scale_color_manual(values = c('black', 'red')) +
		coord_fixed() +
		expand_limits(x = 0, y = 0) +
		theme(legend.position = 'none') +
		labs(x = 'median(m6A/input)', y = 'median(igg/input)') +
		ggtitle('ip vs igg enrichment', 'ip vs input DE genes with p < 0.05 in red')
```


```{r get_genome_and_gtf, echo = F}
library(BSgenome)
library(GenomicFeatures)

txdb <- makeTxDbFromGFF(paste0(root_dir, 'shared/annotations/dm6.gtf'))
dm6_genome <- readDNAStringSet(paste0(root_dir, 'shared/genomes/dm6.fa')) 

# rename the chr names, as in the original dm6.fasta they have have some stuff appended after 2L, etc
names(dm6_genome) <- names(dm6_genome) %>%
	tibble(names = .) %>%
	separate(names, into = c('chr'), extra = 'drop')  %$%
	chr

gene_exons <- exonsBy(txdb, by = 'gene') %>%
	# collapse the ranges, so that overlapping exons are joined together
	reduce() %>%
	# get the data to tibble
	as_tibble %>%
	# filter for only cannonical chromosomes
	filter(seqnames %in% c('3R', '2R', '3L', '2L', 'X', 'Y', '4')) %>%
	makeGRangesListFromDataFrame(split.field = 'group_name')

tx_exons <- exonsBy(txdb, by ='tx', use.names = T) %>%
	reduce() %>%
	# get the data to tibble
	as_tibble %>%
	# filter for only cannonical chromosomes
	filter(seqnames %in% c('3R', '2R', '3L', '2L', 'X', 'Y', '4')) %>%
	makeGRangesListFromDataFrame(split.field = 'group_name')
```

```{r get_sequences, echo = F}
get_sequences <- function(exon_list){
	llply(exon_list, function(gene){
		chr <- gene[1] %>% seqnames %>% as.character
		strand <- gene[1] %>% strand %>% as.character

		# get the sequences from a given chromosome, between the exon starts and ends
		sequence <- extractAt(dm6_genome[[chr]], at = ranges(gene))

		# join ranges together
		sequence <- unlist(sequence)

		# if reverse strand, take the reverse complement
		if(strand == '-'){
			sequence <- reverseComplement(sequence)
		}

		return(sequence)
	}) %>%
	DNAStringSet
}

gene_sequences <- get_sequences(gene_exons)
tx_sequences <- get_sequences(tx_exons)
```


```{r save_sig_candidates, echo = F}
big_table_enrichment_diff <- enrichment_diff %>%
	inner_join(big_table, by = 'gene_name') %>%
	dplyr::rename(median_enrichment_diff = enrichment_diff) %>%
	inner_join(ip_vs_input.resLFC %>%
			   	dplyr::select(gene_name, padj, log2FoldChange), by = 'gene_name') %>%
	dplyr::rename(p_value = padj)

m6a_candidate_table <- big_table_enrichment_diff %>%
	filter(median_enrichment_diff > 1, log2FoldChange > 1, p_value < 0.05) %>%
	dplyr::select(-log2FoldChange)

m6a_candidate_median_ip_tpm <- m6a_candidate_table %>%
	dplyr::select(gene_name, ip_1_tpm:ip_3_tpm) %>%
	gather('obs', 'value', -gene_name) %>%
	group_by(gene_name) %>%
	summarise(median_ip_tpm = median(value))

m6a_candidate_table <- m6a_candidate_median_ip_tpm %>%
	inner_join(m6a_candidate_table, by='gene_name')

m6a_candidate_table %>%
	arrange(desc(median_ip_tpm)) %>%
	write_excel_csv(paste0(michela_m6a_root, 'data/candidates/m6a_candidate_expression.csv'))
```

```{r get_m6a_candidate_sequences, echo = F}
m6a_candidate_ids <- genes %>%
	filter(gene_name %in% m6a_candidate_table$gene_name) %$%
	gene_id

# select rest of genes depending on their tpm in the input 
rest_ids <- enrichment_data %>%
	# select sequences which are not candidates
	filter(!(gene_name %in% m6a_candidate_table$gene_name),
		   gene_id %in% names(gene_sequences),
		   pull_down_condition == 'ip') %>%
	# filter by expression and enrichment
	filter(input > 0.5, tpm_enrichment < 1) %>%
	group_by(gene_id) %>%
	summarise(passing_filter = n()) %>%
	# select only which pass the filter for all three replicates
	filter(passing_filter == 3) %$%
	gene_id

# we don't need this, as we compare candidates to rest...
m6a_candidate_seq <- gene_sequences[m6a_candidate_ids]
m6a_candidate_tx_seq <- tx_sequences[filter(tx2gene, gene_id %in% m6a_candidate_ids) %$% tx_id]

rest_seq <- gene_sequences[rest_ids]

get_windowed_sequences <- function(seqs, q_seq_len, w_size){
	w_min <- q_seq_len - w_size
	w_max <- q_seq_len + w_size
	seqs[width(seqs) > w_min & width(seqs) < w_max]
}

# get control sequences which are comparable to candidates in size
get_control_seq <- function(m6a_candidate_seq, rest_seq, sample_size_mult){
	m6a_candidate_seq %>%
		llply(function(sq){
			len <- length(sq)
			
			window_size <- 10
			windowed_seqs <- get_windowed_sequences(rest_seq, len, window_size)

			while(length(windowed_seqs) < sample_size_mult *2){
				window_size <- window_size * 10
				windowed_seqs <- get_windowed_sequences(rest_seq, len, window_size)
			}

			out_seq <- windowed_seqs %>%
				sample(sample_size_mult)
			
			out_seq
		}) %>%
		unname() %>%
		do.call(c, .) %>%
		unique
}

# select control genes, one per candidate, with rouglhy the same length, by random
control_seq <- get_control_seq(m6a_candidate_seq, rest_seq, sample_size_mult = 1)
control_seq_2 <- get_control_seq(m6a_candidate_seq, rest_seq, sample_size_mult = 2)
control_tx_seq <- tx_sequences[filter(tx2gene, gene_id %in% names(control_seq)) %$% tx_id]
control_tx_2_seq <- tx_sequences[filter(tx2gene, gene_id %in% names(control_seq_2)) %$% tx_id]
```

```{r save_sequences, echo = F}
writeXStringSet(m6a_candidate_seq,
				paste0(michela_m6a_root, 'data/candidates/candidates.fa'))

writeXStringSet(m6a_candidate_tx_seq,
				paste0(michela_m6a_root, 'data/candidates/candidates_tx.fa'))

writeXStringSet(control_seq,
				paste0(michela_m6a_root, 'data/candidates/control_seqs.fa'))

writeXStringSet(control_tx_seq,
				paste0(michela_m6a_root, 'data/candidates/control_seqs_tx.fa'))

writeXStringSet(control_tx_seq,
				paste0(michela_m6a_root, 'data/candidates/control_seqs_2_tx.fa'))

writeXStringSet(rest_seq,
				paste0(michela_m6a_root, 'data/candidates/rest_seqs.fa'))
```

### Candidate motif analysis

Next, in order to identify motifs _de-novo_ we used DREME. The input was our candidate sequences (on the gene level) vs a set of control sequences. The control sequences were selected semi-random from the set of not-methylated genes: we choose the control sequences to have similar length distribution as our input sequences.

```{r read_motif_result, echo = F}
source(paste0(root_dir, 'shared/code/R/parseFimoOut.R'))
a <- 1
m6a_candidate_motif_coverage <- paste0(michela_m6a_root, 'data/candidates/fimo_candidates/fimo.tsv') %>%
	parseFimoOut(gene_features, tx2gene, nbins = 15)

m6a_control_motif_coverage <- paste0(michela_m6a_root, 'data/candidates/fimo_control/fimo.tsv') %>%
	parseFimoOut(gene_features, tx2gene, nbins = 15)
```

```{r plot_motif_coverage, fig.width = 10, fig.height = 5, echo = F}
plot_all_motif_coverage <- function(motif_coverage){
	motif_coverage %>%
	ggplot(aes(start, fill = motif_id)) +
		geom_histogram(aes(y=..count../sum(..count..)),binwidth = 0.1,boundary = 0,  closed = 'left', color = 'black') +
		scale_x_continuous(labels = c('5\'', 'CDS Start', 'CDS End', '3\'')) +
		scale_y_continuous(breaks = c(0.0, 0.01, 0.02)) +
		geom_vline(xintercept = 1, linetype = 'dashed') +
		geom_vline(xintercept = 0, linetype = 'dashed') +
		scale_fill_manual(values=wes_palette(n=5, name="Zissou1")) +
		facet_grid(motif_id~type) +
		labs(x='') +
		ggtitle('Coverage of top5 differential motifs in m6a candidates') +
		theme(strip.text.y = element_blank())
}

m6a_candidate_motif_coverage$type = 'candidate'
m6a_control_motif_coverage$type = 'control'

all_motif_coverage <- bind_rows(m6a_candidate_motif_coverage,
								m6a_control_motif_coverage)

all_motif_coverage %>%
	plot_all_motif_coverage
```

```{r define_motif_coverage_function, echo = F}
coverage_plot <- function(m6a_candidate_motif_coverage, gene_names){
	m6a_candidate_motif_coverage %>%
	group_by(feature_type, gene_name, bin, motif_id) %>%
	# add counts belonging to the same motif so that the plot is cleaner
	summarise(norm_count = sum(norm_count)) %>%
	filter(gene_name %in% gene_names) %>%
	ggplot(aes(bin, norm_count, fill = motif_id)) +
		geom_histogram(position = 'stack', stat ='identity', color = 'black', width = 1) +
		scale_x_continuous(limits = c(-1, 16), breaks = c(0,5, 10, 15), labels = c('5\'', 'cdsS', 'cdsE', '3\''), expand = c(0,0)) +
		scale_y_continuous(expand = c(0,0), limits = c(0.0, 1.0), breaks = c(0.0, 0.2, 0.4, 0.6, 0.8, 1.0)) +
		geom_vline(xintercept = 5, linetype = 'dashed') +
		geom_vline(xintercept = 10, linetype = 'dashed') +
		scale_fill_manual(values=wes_palette(n=5, name="Zissou1")) +
		facet_wrap(~gene_name, ncol = 4) +
		labs(x = '')
}

m6a_motif_count <- m6a_candidate_motif_coverage %>%
	group_by(gene_name, feature_type) %>%
	summarise(count = n()) %>%
	spread(feature_type, count, fill = 0)
```

```{r plot_genes_with_many_motifs, echo = F, fig.width = 10, fig.height = 7.5, eval = F}
m6a_motif_count %>% 
	filter(cds + threep + fivep >= 40) %$%
	gene_name %>%
	coverage_plot(m6a_candidate_motif_coverage, .) +
		ggtitle('Genes with at least 40 total motifs')

```

```{r plot_genes_with_3p_motif, echo = F, fig.width = 10, fig.height = 4.5}
# get genes which are only int the 3p
m6a_3p_candidates <- m6a_motif_count %>% 
	filter(cds + fivep + threep > 10) %>%
	filter((cds < 10& fivep < 10 & threep - 10 > cds & threep - 10 > fivep) |
		   ( threep/cds > 3 & threep/fivep > 3)) %$%
	gene_name

m6a_3p_candidates %>%
	sample(12) %>%
	coverage_plot(m6a_candidate_motif_coverage, .) +
		ggtitle('Example genes with most motifs in 3\' UTR')
```

```{r plot_genes_with_5p_motif, echo = F, fig.width = 10, fig.height = 4.5}
m6a_5p_candidates <- m6a_motif_count %>% 
	filter(cds + fivep + threep > 10) %>%
	filter((cds < 10 & threep < 10 & fivep - 10 > cds & fivep - 10 > threep) |
		   (fivep/cds > 3 & fivep/threep > 3)) %$%
	gene_name

m6a_5p_candidates %>%
	coverage_plot(m6a_candidate_motif_coverage, .) +
		ggtitle('Genes with most motifs in 5\' UTR')
```

```{r plot_genes_with_cds_motif, echo = F, fig.width = 10, fig.height = 4.5}
m6a_cds_candidates <- m6a_motif_count %>% 
	filter(cds + fivep + threep > 10) %>%
	filter((fivep < 10 & threep < 10 & cds > 10)|
		   (cds/fivep > 3 & cds/threep > 3)) %$%
	gene_name

m6a_cds_candidates %>%
	coverage_plot(m6a_candidate_motif_coverage, .) +
		ggtitle('Genes with most motifs in CDS')
```

```{r plot_genes_with_motif_in_both_utrs, echo = F, fig.width = 10, fig.height = 4.5, eval = F}
m6a_motif_count %>% 
	filter(cds + fivep + threep > 10) %>%
	filter((fivep - 10 > cds & threep - 10 > cds & cds < 10)|
		   (fivep/cds > 3 & threep/cds > 3)) %$%
	gene_name %>%
	coverage_plot(m6a_candidate_motif_coverage, .) +
		ggtitle('Genes with most motifs in CDS')
```

```{r create_gene_id_2_met_table, echo = F}
gene2met <- esat_counts %>%
	ungroup %>%
	dplyr::select(gene_id, gene_name) %>%
	unique

gene2met$m6a_type = 'normal'

gene2met <- gene2met %>%
	mutate(m6a_type = ifelse(gene_id %in% m6a_candidate_ids, 'neg', m6a_type),
		   m6a_type = ifelse(gene_name %in% m6a_5p_candidates, '5\'', m6a_type),
		   m6a_type = ifelse(gene_name %in% m6a_3p_candidates, '3\'', m6a_type),
		   m6a_type = ifelse(gene_name %in% m6a_cds_candidates, 'CDS', m6a_type),
		   m6a_type = ifelse(gene_id %in% names(control_seq), 'control', m6a_type))
```

#### Feature distribution of candidates

Next we check if there is a length distribution variation between our candidate groups. 

```{r plot_feature_candidate_group_length_dist, echo = F, fig.width = 9, fig.height = 4}
gene_feature_lengths <- gene_features %>%
	group_by(gene_id) %>%
	summarise(threep = mean(threep_end - threep_start, na.rm = T),
			  fivep = mean(fivep_end - fivep_start, na.rm = T),
			  cds_length = mean(cds_length, na.rm = T)) %>%
	inner_join(gene2met, by = 'gene_id') %>%
	filter(m6a_type != 'normal') %>%
	gather('feature_type', 'mean_length', threep, fivep, cds_length)

gene_feature_lengths %>%
	mutate(feature_type = fct_recode(feature_type, '3\' length' = 'threep', '5\' length' = 'fivep', 'CDS length' = 'cds_length' )) %>%
	ggplot(aes(m6a_type, mean_length, color = m6a_type)) +
		geom_boxplot() +
		scale_y_log10() +
		facet_grid(~feature_type) +
		ggtitle('Distribution of feature lengths of m6a candidates') +
		theme(legend.position = 'bottom') +
		labs(x ='', y = 'mean(length)', color = 'methylation type')
```

### GO analysis of candidates

```{r get_enriched_go_terms, echo = F}
m6a_go <- esat_counts %>%
	filter(condition == 'input',
		   count > 4) %>%
	group_by(gene_id) %>%
	summarise(passing_filter = n()) %>%
	filter(passing_filter == 3) %$%
	gene_id %>%
	getGOData(genes_of_interest = m6a_candidate_ids,
			  control_genes = .,
			  gene_id2go = gene_id2go)

m6a_go_res <- m6a_go %>%
	runTest(statistic='fisher') %>%
	GenTable(m6a_go, classicFisher =.)
```

First we looked at enriched GO terms in candidates vs rest of detected mRNAs.

```{r plot_candidate_vs_rest_go, echo = F}
m6a_go_res %>%
	mutate(pval = as.numeric(classicFisher),
		   foldChange = Significant / Expected) %>%
	arrange(foldChange) %>%
	filter(Significant > 4) %>%
	mutate(pos = 1:n(),
		   Term = factor(Term, levels = Term),
		   star = ifelse(pval < 0.05, '*', ''),
		   star = ifelse(pval < 0.01, '**', star),
		   star = ifelse(pval < 0.001, '***', star)) %>%
	ggplot(aes(Term, foldChange)) +
		geom_bar(stat='identity', color = 'black',fill = wes_palette(n=3, name="Rushmore1")[3]) +
		scale_y_continuous(limits = c(0, 8), breaks = 0:7, labels = 0:7) +
		coord_flip() +
		geom_text(aes(label = star), hjust = -0.5) + 
		labs(x = 'GO Term', y = 'Fold Change') +
		ggtitle('Enriched GO terms in m6a candidates')
```

### Look at circles in polyA data

```{r load_m6a_find_circ_data, echo = F, include = F}
txdb <- makeTxDbFromGFF(paste0(root_dir, 'shared/annotations/dm6.gtf'))
annot.file = paste0(root_dir, "shared/annotations/dm6.sqlite")

saveDb(txdb, file = annot.file)

annot.list = loadAnnotation(annot.file)

data.path = paste0(michela_m6a_root, 'data/mapping/circrna/')

circ_experiment_paths = llply(samples,function(x){
  paste0(data.path, '/', x, '/find_circ_run/circ_splice_sites.bed')
})

cdata = data.frame(sample = samples, filename = circ_experiment_paths %>% unlist)

### workaround as SummarizedExperiment currently gives some weird error. This trick does it
rownames(cdata) <- cdata$sample

### put the circs in a SummarizedExperiment object
circs.se <- summarizeCircs(cdata, keepCols = 1:12)

### annotate circs
circs.se <- annotateCircs(circs.se, annot.list = annot.list) %>% circLinRatio
```

```{r get_detected_circrnas, echo = F}
### save circs quantification in a tibble instead of results table
circs_tb <- circs.se %>% resTable %>% as.tibble

circs_tb <- circs_tb %>%
	gather('observation', 'value', ip_1_circ:input_3_ratio) %>%
	separate(observation, into = c('condition', 'replicate', 'observation'), sep= '[_]') %>%
	inner_join(genes %>% dplyr::select(gene_name, gene_id), by = 'gene_id')

circs_counts <- circs_tb %>%
	filter(width > 50, observation == 'circ') %>%
	group_by(condition, replicate, gene_name, gene_id) %>%
	summarise(value = sum(value))	

circs_abundances <- circs_counts %>%
	group_by(condition, replicate) %>%
	mutate(value = value / sum(value) * 1e2)

# show circles
to_join_1 <- circs_counts %>%
	unite('sample', condition, replicate) %>%
	spread(sample, value)
	
to_join_2 <- circs_abundances %>%
	unite('sample', condition, replicate) %>%
	spread(sample, value)

polya_circs_table <- inner_join(to_join_1, to_join_2, by = c('gene_id', 'gene_name'), suffix = c('.count', '.norm_abundance'))

write_excel_csv(polya_circs_table, paste0(michela_m6a_root, 'data/candidates/polya_circs_table.csv'))
```

```{r plot_circles_which_are_present_in_polya, echo = F}
circs_abundances %>%
	dplyr::rename(abundance = value) %>%
	ggplot(aes(condition, abundance, fill = condition)) +
		geom_violin() +
		geom_point(position = 'jitter') +
		scale_y_continuous(trans = 'log2') +
		scale_fill_manual(values=wes_palette(n=3, name="GrandBudapest1")) +
		ggtitle('circRNAs detected in PolyA data',
				subtitle = 'Counts across the BS junction')
```

```{r read_fc_output, echo = F}
rfp_fc <- readRDS(paste0(root_dir, 'nagarjuna/rfp/data/counts/feature_counts.rds'))

colnames(rfp_fc$counts) <- c('ld_1', 'ld_2', 'hd_1', 'hd_2')

rfp_counts <- rfp_fc$counts %>%
	as.data.frame

rfp_counts <- rfp_counts %>%
	rownames_to_column(var = 'gene_id') %>%
	as_tibble %>%
	separate(gene_id, into = c('gene_id'), extra = 'drop')

# get gene names from the counts which are not in biomart genes
n <- rfp_counts %>%
	filter(!(gene_id %in% genes$gene_id)) %$%
	gene_id

# we can get these names and convert them to their current symbols using: https://flybase.org/convert/id
# the output is saved to FlyBase_IDs.txt

# get only ones which really changed
convert_ids <- read_table2('../../../../FlyBase_IDs.txt')%>%
	filter(submitted_id != current_id) %>%
	dplyr::rename(gene_id = submitted_id) %>%
	dplyr::select(gene_id, converted_id)

# update the gene_ids
rfp_counts <- rfp_counts %>%
	left_join(convert_ids, by = 'gene_id') %>%
	# if convert id exists
	mutate(gene_id = ifelse(is.na(converted_id), gene_id, converted_id)) %>%
	dplyr::select(-converted_id)

# use inner join as all the id should be updated by now
rfp_counts <- rfp_counts %>%
	inner_join(genes, by = 'gene_id') %>%
	filter(gene_biotype == 'protein_coding')
```

```{r calculate_fc_tpm, echo = F}
rfp_tpm <- rfp_counts %>%
	gather('experiment', 'count', ld_1:hd_2) %>%
	group_by(experiment) %>%
	mutate(tpm = count / gene_length,
		   tpm = tpm / sum(tpm) * 1e6) %>%
	dplyr::select(-count) %>%
	spread(experiment, tpm)
```

```{r create_deseq_rfp, echo = F}
rfp_metadata <- data.frame(condition = factor(c('ld', 'ld', 'hd', 'hd'), levels = c('ld', 'hd')),
						   replicate = c(1,2,1,2),
						   row.names = c('ld_1', 'ld_2', 'hd_1', 'hd_2'))

dds <- DESeqDataSetFromMatrix(as.matrix(rfp_fc$counts),
							  colData = rfp_metadata,
							  design = ~condition)

dds <- DESeq(dds) 

res <- results(dds, alpha = 0.01)
resLFC <- lfcShrink(dds = dds, res = res, coef = 'condition_hd_vs_ld') %>%
	data.frame %>%
	rownames_to_column(var = 'gene_id') %>%
	as_tibble %>%
	left_join(genes, by = 'gene_id')
```

```{r plot_enriched_genes_tpm_by_rank, echo = F, fig.width = 10, fig.height = 7, eval = F}
library(mgcv)
sig_genes_up <- resLFC %>%
	filter(log2FoldChange > 1, padj < 0.01) %$%
	gene_id

rfp_tpm_ranked <- rfp_tpm %>%
	filter(gene_id %in% sig_genes_up) %>%
	arrange(desc(hd_1 + hd_2 - ld_1 - ld_2)) %>%
	mutate(rank = 1:n()) 

rfp_tpm_ranked %>%
	filter(gene_id %in% sig_genes_up) %>%
	gather('experiment', 'tpm', c('ld_1', 'ld_2', 'hd_1', 'hd_2')) %>%
	separate('experiment', into = c('condition', 'replicate')) %>%
	ggplot(aes(rank, tpm, color = condition)) +
		geom_smooth(aes(linetype=replicate)) + 
		geom_point(size = 0.7, alpha = 0.5) +
		geom_rug(sides = 'l', alpha=0.1, position = 'jitter') +
		scale_color_manual(values=wes_palette(n=2, name="Darjeeling1")) +
		scale_y_log10()
```

```{r plot_enriched_genes_tpm_density, echo = F, eval = F}
rfp_tpm_ranked %>%
	gather('experiment', 'tpm', c('ld_1', 'ld_2', 'hd_1', 'hd_2')) %>%
	separate('experiment', into = c('condition', 'replicate')) %>%
	mutate(log_tpm = log10(tpm)) %>%
	filter(gene_biotype == 'protein_coding') %>%
	ggplot(aes(log_tpm, fill = condition)) +
		geom_density(alpha = 0.7)+
		scale_fill_manual(values=wes_palette(n=2, name="Darjeeling1"))
```

```{r plot_ld_vs_hd_tpm, echo = F, eval = F}
rfp_tpm_ranked %>%
	filter(gene_id %in% sig_genes_up) %>%
	mutate(ld = log10((ld_1 + ld_2) / 2),
		   hd = log10((hd_1 + hd_2) / 2)) %>%
	ggplot(aes(hd, ld)) +
		geom_point(aes(color = (hd - ld) > 1)) +
		coord_fixed()
```

```{r plot_ld_vs_hd_volcano, echo = F, eval = F}
resLFC %>%
	mutate(neg_log10_p = -1 * log10(padj)) %>%
	ggplot(aes(log2FoldChange, neg_log10_p)) +
		geom_point(alpha = 0.5, size = 1)
```

## Translation efficiency

```{r download_cds_lengths, echo = F}
cds_lengths <- gene_features %>%
	group_by(gene_id) %>%
	summarise(cds_length = max(cds_length))
```

```{r estimate_translational_efficiency, echo = F}
input_abundances <- esat_counts %>%
	dplyr::select(-tpm, -gene_start, -gene_end, -gene_biotype, -gene_start, -gene_length, -strand) %>%
	filter(condition == 'input') %>%
	inner_join(cds_lengths, by = 'gene_id') %>%
	group_by(replicate) %>%
	mutate(norm_count = count / sum(count) * 1e6) %>%
	group_by(gene_id, gene_name) %>%
	summarise(mnc = mean(norm_count))

rfp_abundances <- rfp_counts %>%
	dplyr::select(gene_id:hd_2) %>% 
	gather('experiment', 'count', ld_1:hd_2) %>%
	separate(experiment, into = c('condition', 'replicate')) %>%
	inner_join(cds_lengths, by = 'gene_id') %>%
	group_by(condition, replicate) %>%
	mutate(norm_count = count / cds_length,
		   norm_count = norm_count / sum(norm_count) * 1e6) %>%
	group_by(gene_id, condition) %>%
	summarise(mnc = mean(norm_count))

abundances <- input_abundances %>%
	inner_join(rfp_abundances, by = 'gene_id', suffix = c('.input', '.rfp')) %>%
	mutate(translation_efficiency = mnc.rfp / mnc.input,
		   seq_type = ifelse(gene_id %in% m6a_candidate_ids, 'candidate', 'not candidate'))
```



```{r plot_translational_efficiency_density, echo = F}
abundances %>%
	ggplot(aes(translation_efficiency, fill = seq_type)) +
		geom_density(alpha = 0.5) +
		scale_x_log10() +
		facet_wrap(~condition)
```

```{r plot_translational_efficiency_ld_vs_hd, echo = F}
abundances %>%
	dplyr::select(gene_id, condition, translation_efficiency, seq_type) %>%
	mutate(log_te = log10(translation_efficiency)) %>%
	dplyr::select(-translation_efficiency) %>%
	spread(condition, log_te) %>%
	ggplot(aes(ld, hd)) +
		geom_vline(xintercept = 0, color = 'red', linetype = 'dashed') +
		geom_smooth(method = 'lm') +
		geom_point(alpha = 0.7, size = 0.1) +
		scale_x_continuous(breaks = c(-4, -2, 0, 2), limits = c(-5, 3)) +
		scale_y_continuous(breaks = c(-4, -2, 0, 2), limits = c(-5, 3)) +
		coord_fixed() +
		facet_wrap(~seq_type)
```

#### Efficiency of different groups of m6a candidates

```{r plot_abundance_of_candidates, echo = F}
pl_in <- abundances %>%
	inner_join(gene2met, by = c('gene_name', 'gene_id')) %>%
	filter(m6a_type != 'normal') %>% 
	filter(condition == 'ld') %>%
	dplyr::select(-mnc.input) %>%
	gather('observation', 'value', mnc.rfp:translation_efficiency) %>%
	filter(is.finite(value))

m6a_mu <- pl_in %>%
	group_by(m6a_type, observation) %>%
	summarise(grp.median = median(value))

log_breaks = c(0.001, 0.01, 0.1, 1.0, 10, 100, 1000, 10000)

pl_in %>%
	ggplot(aes(m6a_type, value, color = m6a_type)) +
		geom_hline(yintercept = 1, linetype = 'dashed') + 
		geom_boxplot() +
		scale_y_log10(breaks =log_breaks, labels = log_breaks) +
		ggtitle('RFP abundances of differently methylated genes') +
		facet_wrap(~observation) +
		theme(legend.position = 'bottom') +
		labs(x = '', color = 'methylation type') 
```
 
### Localisation of m6a candidates

Next, we checked if candidate mRNAs localise somewhere in the cell fractionation data. 

```{r load_cell_fraction_data, echo = F}
fraction_fc <- readRDS(paste0(root_dir, 'mor_osnat/synaptosomes/data/counts/feature_counts.rds'))
fraction_counts <- fractions_fc$counts %>%
	as.data.frame %>%
	rownames_to_column(var = 'gene_id') %>%
	as_tibble %>%
	gather('experiment', 'count', -gene_id) %>%
	mutate(experiment = sapply(strsplit(experiment, '[.]'), `[`, 14)) %>%
	inner_join(genes, by ='gene_id') %>%
	filter(gene_biotype == 'protein_coding')
```

```{r calculate_fraction_tpms, echo = F}
fraction_tpm <- fraction_counts %>%
	dplyr::select(gene_id, gene_name, experiment, count, gene_length) %>%
	group_by(experiment) %>%
	mutate(tpm = count / gene_length,
		   tpm = tpm / sum(tpm) * 1e6)
```

Lets look at how does the TPM values change based on different fractions.

```{r plot_m6a_candidate_localised_expression, echo = F, fig.width = 9, fig.height = 4}
fraction_tpm %>%
	separate(experiment, into = c('condition', 'replicate')) %>%
	group_by(gene_id, gene_name, condition) %>%
	summarise(mean.tpm = mean(tpm)) %>%
	inner_join(input_abundances, by = c('gene_id', 'gene_name')) %>%
	inner_join(gene2met, by = c('gene_id', 'gene_name')) %>%
	mutate(normalised_tpm = mean.tpm / mnc) %>%
	filter(m6a_type != 'normal',
		   condition %in% c('pel1', 'pel2', 'sup2')) %>%
	mutate(condition = mapvalues(condition, to = c('nuc', 'syn', 'cyt'), from = condition)) %>%
	ggplot(aes(condition, mean.tpm, color = m6a_type)) +
		geom_boxplot() +
		scale_y_log10(breaks = c(0.1, 1, 10, 100, 1000, 10000), labels = c(0.1, 1, 10, 100, 1000, 10000)) +
		facet_wrap(~m6a_type, ncol = 5) +
		theme(legend.position = 'bottom') +
		ggtitle('Localisation of m6a candidates in different fractions') +
		labs(x = '', color = 'methylation type')
```

Look if there is a difference between circ localization of circles whose host genes are methylated. This is probably a long-shot...

```{r load_fraction_find_circ_data, echo = F, include = F}
fraction_samples <- fraction_counts %$%
	experiment %>%
	unique

txdb <- makeTxDbFromGFF(paste0(root_dir, 'shared/annotations/dm6.gtf'))
annot.file = paste0(root_dir, "shared/annotations/dm6.sqlite")

saveDb(txdb, file = annot.file)

annot.list = loadAnnotation(annot.file)

data.path = paste0(root_dir, 'mor_osnat/synaptosomes/data/mapping/circrna/')

circ_experiment_paths = llply(fraction_samples,function(x){
  paste0(data.path, x, '/find_circ_run/circ_splice_sites.bed')
})

cdata = data.frame(sample = fraction_samples, filename = circ_experiment_paths %>% unlist)

### workaround as SummarizedExperiment currently gives some weird error. This trick does it
rownames(cdata) <- cdata$sample

### put the circs in a SummarizedExperiment object
circs.se <- summarizeCircs(cdata, keepCols = 1:12)

### annotate circs
circs.se <- annotateCircs(circs.se, annot.list = annot.list) %>% circLinRatio
```

```{r read_number_of_reads_per_fraction, echo = F}
fraction_reads <- fraction_samples %>%
	ldply(function(sample){
		readStarLog(paste0(root_dir,'mor_osnat/synaptosomes/data/mapping/star/', sample, '.Log.final.out')) %>% data.frame(sample = sample)
	}) %>%
	as_tibble %>%
	separate(sample, into = c('condition', 'replicate'), extra = 'drop') %>%
	group_by(replicate) %>%
	mutate(read_ratio = uniq_reads / sum(uniq_reads)) %>% 
	dplyr::select(condition, replicate, input_reads)
```


```{r process_fraction_circs, echo = F}
fraction_circs <- circs.se %>% resTable %>% as_tibble %>%
	gather('observation', 'value', homog_1_circ:sup2_2_ratio) %>%
	separate(observation, into = c('condition', 'replicate', 'observation'), sep = '[_]') %>%
	filter(observation == 'circ', width > 50)

m6a_host_circs <- fraction_circs %>%
	full_join(gene2met, by = 'gene_id') %>%
	# join with the number of input reads, so we can normalise
	inner_join(fraction_reads, by = c('condition', 'replicate')) %>%
	# normalise the valus to account for library size
	mutate(norm_count = value / input_reads * 1e7) %>%
	group_by(gene_id, condition, m6a_type) %>%
	summarise(mnc = mean(norm_count))

m6a_host_circs %>%
	filter(condition %in% c('pel1', 'pel2', 'sup2')) %>%
	ggplot(aes(condition, mnc, color = m6a_type)) +
		geom_boxplot() +
		facet_wrap(~condition) +
		scale_y_log10()
```

```{r calculate_fraction_circ_abundance, echo = F}
fraction_circ_abundance <- fraction_circs %>%
	inner_join(fraction_reads, by = c('condition', 'replicate')) %>%
	mutate(norm_count = value / input_reads * 1e7)

fraction_circ_abundance %>%
	ggplot(aes(norm_count, color = condition)) +
		geom_density(adjust = 2) + 
		scale_x_log10() +
		scale_color_manual(values = wes_palette(n=5, name ='Darjeeling1')) +
		ggtitle('circRNA abundance distribution similar between fractions')
```

```{r plot_correlations_between_fractions, echo = F}
ticks <- c(0.1, 1, 10, 100)

pl_in <- fraction_circ_abundance %>%
	group_by(chr, start, end, strand, condition) %>%
	summarise(mnc = mean(norm_count)) %>%
	filter(condition %in% c('pel1', 'pel2', 'sup2')) %>%
	spread(condition, mnc) %>%
	dplyr::rename(nuclei = pel1,
				  synapses = pel2,
				  cytoplasm = sup2)

pl1 <- pl_in %>%
	ggplot(aes(cytoplasm, synapses)) +
		geom_point(size = 0.7, alpha = 0.8) +
		scale_x_log10(breaks = ticks, labels = ticks, limits = c(0.1, 100)) +
		scale_y_log10(breaks = ticks, labels = ticks, limits = c(0.1, 100)) +
		coord_fixed()

pl2 <- pl_in %>%
	ggplot(aes(nuclei, cytoplasm)) +
		geom_point(size = 0.7, alpha = 0.8) +
		scale_x_log10(breaks = ticks, labels = ticks, limits = c(0.1, 100)) +
		scale_y_log10(breaks = ticks, labels = ticks, limits = c(0.1, 100)) +
		coord_fixed()

ttl <- ggdraw()  + draw_label('Localisation of circRNAs', fontface = 'bold')
p <- plot_grid(pl1, pl2, ncol = 2)
plot_grid(ttl, p, ncol = 1, rel_heights = c(0.1, 1))
```

---
# Kallisto

Second, we also calculated the transcript counts with using kallisto (ref needed). This, instead of mapping the reads creates pseudo-counts with building a probabilistic model.
---

```{r load_kallisto_results, echo = F, eval=F}
####
# import kallisto using read_table2
####
kallisto_dir = paste0(michela_m6a_root, 'data/kallisto_quant/')

kallisto_data <- samples %>% ldply(function(smpl){
		df <- read_table2(paste0(kallisto_dir, '/', smpl, '/abundance.tsv'))
		df$sample <- smpl

		df
	}) %>% 
	as_tibble %>%
	separate(sample, into = c('condition', 'replicate'), sep = '[_]') %>%
	dplyr::rename(tx_id = target_id) %>%
	mutate(tx_id = as.factor(tx_id),
		   condition = as.factor(condition)) %>%
	left_join(txs, by = 'tx_id')

####
# import kallisto with tximport
###


kallisto_metadata <- tibble(sample = samples) %>%
	separate(sample, into = c('condition', 'replicate', 'rnd'), remove = F) %>%
	# remove randomly generated suffix
	dplyr::select(-rnd) %>%
	mutate(path = paste0(kallisto_dir, sample),
		   condition = factor(condition, levels = c('input', 'igg', 'ip'))) %>%
	# sort tibble by factor
	arrange(condition)

txi <- kallisto_metadata %>%
	mutate(files = paste0(path, '/abundance.tsv')) %>%
	{
		files <- .$files
		names(files) <- .$sample 
		tximport(files, type = 'kallisto', tx2gene = tx2gene, ignoreAfterBar = T)
	}

dds <- DESeqDataSetFromTximport(txi, as.data.frame(kallisto_metadata), ~condition + replicate)

# create kallisto counts from txi on the gene level (together with tpm's)
kallisto_gene_counts <- txi$counts %>% 
	# get counts and load them as dataframe
	as.data.frame %>%
	# convert rownames to a column
	rownames_to_column(var = 'gene_id') %>%
	# convert to tibble
	as_tibble %>%
	# join with metadata about genes and txs
	left_join(genes, by = 'gene_id') %>%
	# create column for run and counts
	gather('run', 'count', samples) %>%
	# separate the run column and drop random overhang
	separate(run, into = c('condition', 'replicate'), extra = 'drop') %>%
	# group by condition and replicate
	group_by(condition, replicate) %>%
	# calculate tpm
	mutate(tpm = count / gene_length,
		   tpm = tpm / sum(tpm) * 1e6)
```

```{r create_combined_data, echo = F, eval = F}

```

```{r calculate_count_correlation_esat_kallisto, echo = F, eval = F}
kallisto_vs_esat <- ddply(combined_counts, .(condition, replicate), function(tb){
	data.frame(correlation = cor(tb$count, tb$esat_count))
})

kallisto_vs_esat %>% kable
```

```{r plot_kallisto_vs_esat, echo = F, eval = F}
combined_counts %>%
	rename(count = 'kallisto_count') %>%
	ggplot(aes(kallisto_count, esat_count)) +
		geom_point() +
		scale_y_log10() +
		scale_x_log10() +
		facet_grid(condition ~ replicate)
```
