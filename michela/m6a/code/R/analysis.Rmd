--- 
title: "m6a analysis"
author: "tsztank"
date: "`r format(Sys.time(), '%d/%B/%Y')`"
output: 
  html_document:
    theme: journal
---

```{r knitr_options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  cache = T,
  autodep = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = NA,
  cache.path = 'cache/',
  fig.path = 'figures/',
  knitr.table.format = 'markdown')
```

```{r load_libraries, echo = F, cache = F}
library(plyr)
library(tidyverse)
library(biomaRt)
library(magrittr)
library(yaml)
library(readr)
library(cowplot)
library(wesanderson)
library(GGally)
library(DESeq2)
library(tximport)
library(kableExtra)
library(metaseqR)
```

```{r load_functions, echo = F, cache = F}
source('../../../../shared/code/R/readStarLog.R')
source('calculateEnrichment.R')

# set the default title spacing for plots
theme_update(plot.title = element_text(hjust = 0),
			 strip.text.x = element_text(margin = margin(c(3,3,3,3))),
			 strip.text.y = element_text(margin = margin(c(3,3,3,3))))

wd <- '../../'

options(knitr.table.format = "markdown")
```

```{r get_gene_name_id_map, echo = F}
options(knitr.table.format = "markdown")

ensembl = useMart('ensembl', dataset = 'dmelanogaster_gene_ensembl')

txs <- ensembl %>%
	getBM(
		  attributes = c('ensembl_gene_id',
						 'ensembl_transcript_id',
						 'external_gene_name',
						 'external_transcript_name',
						 'start_position', 
						 'end_position', 
						 'strand',
						 'gene_biotype'),
		  mart = .) %>%
	as_tibble

colnames(txs) <- c('gene_id', 'tx_id', 'gene_name', 'tx_name', 'gene_start', 'gene_end', 'strand', 'gene_biotype')

txs <- txs %>% mutate(gene_length = gene_end - gene_start)

genes <- txs %>%
	dplyr::select(-tx_id, -tx_name) %>%
	unique %>%
	mutate(gene_length = gene_end - gene_start)
```

```{r load_sample_specification, echo = F}
config = read_yaml('../../config.yaml')
samples <- config$samples
```

```{r parse_star_logfiles, echo = F}
star_log <- samples %>%
	ldply(function(sample){
		readStarLog(paste0(wd,'data/mapping/', sample, '.Log.final.out')) %>% data.frame(sample = sample)
	}) %>%
	as_tibble %>%
	separate(sample, into = c('condition', 'replicate'), extra = 'drop') %>%
	group_by(replicate) %>%
	mutate(read_ratio = uniq_reads / sum(uniq_reads))

star_log %>% kable(format.args = list(decimal.mark = ',', big.mark = " ")) %>% kable_styling(c('striped'), full_width = F, position = "left")
```


ESAT (ref) is a counting toolkit designed for short 3' or 5' libraries. As a check, we also mapped the reads with STAR and then counted the reads on the gene level with ESAT, and correlated the results with counts coming from kallisto+tximport

## Sanity checks

The if we plot the counts and tpm-s (transcript per million) on a log-x scale, we observe a normal distribution which is expected. Also, the mean values of tpm-s are comparable, so it seems there is not big difference between the libraries of the 3 conditions sequenced.

```{r import_esat_counts, echo = F}
esat_dir = paste0(wd, 'data/esat/')
esat_counts <- samples %>%
	# create a dataframe out of counts
	data.frame(sample = .) %>%
	# create a filename column, and load dataframes as a list
	mutate(filename = paste0(esat_dir, sample, '.gene.txt'), 
		   file_contents = map(filename, ~read_table2(.))) %>%
	# expand the lists
	unnest() %>%
	# create tibble
	as_tibble %>%
	# rename columns
	transmute(sample = sample,
			  gene_id = Symbol,
			  count = Exp1) %>%
	# fill non detected genes in each sample with zeros
	spread(sample, count, fill = 0) %>%
	# gather back
	gather('sample', 'count', samples) %>%
	separate(sample, into = c('condition', 'replicate'), extra = 'drop') %>%
	inner_join(genes, by = 'gene_id') %>%
	# we need to group before tmp counting...
	group_by(condition, replicate) %>%
	# look at only mRNAs for now
	filter(gene_biotype == 'protein_coding') %>%
	mutate(tpm = count / gene_length,
		   tpm = tpm / sum(tpm) * 1e6)
```

```{r plot_histogram_tpm, echo =F}
esat_counts %>%
	ggplot(aes(tpm, fill = condition)) +
	geom_density(alpha = 0.8) +
	scale_x_log10() +
	scale_fill_manual(values=wes_palette(n=3, name="GrandBudapest1")) +
	ggtitle('TPM comparison between conditions')
```

```{r plot_histogram_counts, echo =F}
esat_counts %>%
	ggplot(aes(count, fill = condition)) +
	geom_density(alpha = 0.8) +
	scale_x_log10() +
	scale_fill_manual(values=wes_palette(n=3, name="GrandBudapest1")) +
	facet_grid(condition~replicate) +
	theme(axis.text.x = element_text(angle = 45, hjust =1)) +
	ggtitle('Estimated counts of each run')
```

### PCA analysis

```{r create_dds_from_counts, echo = F}
sample_metadata <- tibble(sample = samples) %>%
	separate(sample, into = c('condition', 'replicate'), extra = 'drop') %>%
	unite('sample', condition, replicate, remove =F) %>%
	mutate(condition = factor(condition, levels = c('input', 'IgG', 'IP')),
		   replicate = factor(replicate, levels = c('1','2','3'))) %>%
	# sort tibble by factor
	arrange(condition)

count_matrix <- esat_counts %>%
	unite('sample', c('condition', 'replicate')) %>%
	dplyr::select(sample, count, gene_name) %>%
	# spread values, fill with 0, as NA here means ND = 0 count
	spread(sample, count, fill = 0) %>%
	{
		genes <- .$gene_name
		mx <- dplyr::select(., -gene_name) %>%
			as.matrix

		rownames(mx) <- genes

		mx
	}

# get the columns into the right order
count_matrix <- count_matrix[,sample_metadata$sample]

m6a_dds <- DESeqDataSetFromMatrix(countData = count_matrix,
							  colData = sample_metadata %>% {data.frame(., row.names = .$sample)},
							  design = ~ replicate + condition )
```

From the below PCA plot we can clearly see, that replicate 3 is an outlier, it is therefore probably better to not take it into account.

```{r pca_analysis, echo = F}
vsd <- vst(m6a_dds, blind=FALSE)
pca <- DESeq2::plotPCA(vsd, intgroup=c('condition', 'replicate'), returnData=T) %>%
	as_tibble

pca %>%
	# modify factor level to have consistent colors
	mutate(condition = factor(condition, levels = c('IgG', 'input', 'IP'))) %>%
	ggplot(aes(PC1, PC2, colour = condition, shape = replicate)) + 
	geom_point(size = 4) +
	scale_colour_manual(values=wes_palette(n=3, name="GrandBudapest1"))

```

### Looking at genes of interest

First lets look at 3 genes: Clk, tim and vri.

It seems that for these 3 genes, IgG\_3 is an outlier.

```{r plot_genes_of_interest, echo = F, fig.width = 10, fig.height = 5}
genes_of_interest <- c('vri', 'Clk', 'tim')

plot_genes <- function(tpm, genes, x_lab, metric = 'tpm'){
	tpm %>%
		filter(gene_name %in% genes) %>%
		ggplot(aes_string(x_lab, metric, colour = 'condition', shape = 'replicate')) +
			geom_point(size = 4, position = position_dodge(width=0.3)) +
			scale_colour_manual(values=wes_palette(n=3, name="GrandBudapest1")) +
			scale_y_log10()
}

pl1 <- plot_genes(esat_counts, genes_of_interest, x_lab = 'gene_name', metric = 'tpm')
pl2 <- plot_genes(esat_counts, genes_of_interest, x_lab = 'gene_name', metric = 'count')

plot_grid(pl1, pl2, ncol = 2)
```

Lets look at Mbl separately. Here we again can observe that 3 is an outlier compared to others.

```{r plot_mbl_tpm, echo = F}
plot_genes(esat_counts, c('mbl'), x_lab = 'gene_name', metric = 'tpm')
```

### Correlation between replicates

Next to check any differences between our IP's we looked at correlations between any two IP samples. Overall correlations on the count level are quite good, with IP\_3 being much deeper than the other two samples.

The correlations in the TPM space are a bit worse for IP\_1 vs IP\_3 and IP\_2 vs IP\_3, but still okay.

If we downsample IP\_3 to 9 million reads (so that the sample sizes are preferable), the correlations do not change which is the expected behaviour.


```{r correlation_function, echo = F}
get_cor_plot <- function(data, sx, sy, quant_type = 'count'){
	dat <- data %>%
		unite('run', condition, replicate) %>%
		dplyr::select(gene_id, run, quant_type) %>%
		spread(run, quant_type, fill = 0)

	r <- cor(dat[[sx]], dat[[sy]])

	pl <- dat %>%
		# convert quant_type to log for visualization
		gather('run', 'quant_type', -gene_id) %>%
		mutate(quant_type = log10(quant_type)) %>%
		spread(run, quant_type) %>%
		ggplot(aes_string(x=sx, y=sy)) +
			geom_point(alpha = 0.7, size = 0.5) +
			coord_fixed() +
			labs(y = paste0('log10(', sy, '_', quant_type, ')'),
				 x = paste0('log10(', sx, '_', quant_type, ')'))

	pl <- pl + annotate("text", Inf, -Inf, label = paste0('R = ', round(r, 3)), hjust = 1, vjust = -5)

	if(quant_type == 'count'){
		pl <- pl +
			scale_y_continuous(limits = c(0,6)) +
			scale_x_continuous(limits = c(0,6))
	} else {
		pl <- pl +
			scale_y_continuous(limits = c(-5, 5)) +
			scale_x_continuous(limits = c(-5, 5))
	}

	pl
}
```

##### Raw counts

```{r plot_counts_correlations, echo = F, fig.height = 3, fig.width = 10}
plot_grid(get_cor_plot(esat_counts, 'IP_1', 'IP_3'),
		  get_cor_plot(esat_counts, 'IP_2', 'IP_3'),
		  get_cor_plot(esat_counts, 'IP_1', 'IP_2'),
		  ncol = 3)
```

##### TPMs

```{r plot_tpm_correlations, echo = F, fig.height = 3, fig.width = 10}
plot_grid(get_cor_plot(esat_counts, 'IP_3', 'IP_1', quant_type = 'tpm'),
		  get_cor_plot(esat_counts, 'IP_3', 'IP_2', quant_type = 'tpm'),
		  get_cor_plot(esat_counts, 'IP_1', 'IP_2', quant_type = 'tpm'),
		  ncol = 3)
```

#### Downsampled correlations

```{r downsample_IP_values, echo = F, eval = F}
ip_counts <- esat_counts %>%
	dplyr::select(condition, replicate, gene_name, count) %>%
	filter(condition == 'IP') %>%
	unite('sample', condition, replicate) %>%
	spread(sample, count)

ip_counts <- data.frame(ip_counts[,-1], row.names = ip_counts$gene_name)

downsampled_ip_counts <- ip_counts %>%
	downsample.counts(seed = 10) %>%
	rownames_to_column(var = 'gene_name') %>%
	as_tibble
```

```{r downsample_ip_3, echo =F}
ip_3_counts <- esat_counts %>%
	filter(condition == 'IP', replicate == 3) %>%
	dplyr::select(gene_name, count) %>% {
		rep(.$gene_name, .$count)
	}

ip_3_downsampled <- ip_3_counts %>%
	sample(size = 9*1e6) %>%
	table %>%
	as.data.frame

colnames(ip_3_downsampled) <- c('gene_name', 'IP_3')

ip_3_downsampled <- ip_3_downsampled %>% 
	mutate(gene_name = as.character(gene_name))
```


```{r merge_downsampled_values_back, echo = F, eval = T}
# calculate downsampled counts, as follows: treat each read independently,
# then draw 9 million reads out of 42 million, without replacement, with uniform
# probability
# 
# first drop tmp as it will be recalculated
downsampled_counts <- esat_counts %>%
	dplyr::select(-tpm) %>%
	# remove IP samples 
	filter(condition != 'IP' | replicate != '3') %>%
	# unite columns into samples
	unite('sample', condition, replicate) %>%
	# spread the values before we can inner join with downsampled values
	spread(sample, count) %>%
	# left join so that we get all the values right, replaced with NA's
	left_join(ip_3_downsampled, by = 'gene_name') %>%
	# replace NA's with 0's
	mutate(IP_3 = ifelse(is.na(IP_3), 0, IP_3)) %>%
	#gather columns back
	gather('sample', 'count', IgG_1:IP_3) %>%
	separate(sample, into = c('condition', 'replicate')) %>%
	group_by(condition, replicate) %>%
	# recalculate tpm's
	mutate(tpm = count / gene_length,
		   tpm = tpm / sum(tpm) * 1e6)


# perform a test here
tpms <- downsampled_counts %>%
	dplyr::select(gene_name, tpm, count, replicate, condition) %>%
	inner_join(esat_counts %>%
			   	dplyr::select(replicate, condition, gene_name, tpm, count),
				by=c('replicate', 'condition', 'gene_name'))
```

##### Counts

```{r plot_downsampled_count_correlations, echo = F, fig.height = 3, fig.width = 10}
plot_grid(get_cor_plot(downsampled_counts, 'IP_3', 'IP_1'),
		  get_cor_plot(downsampled_counts, 'IP_3', 'IP_2'),
		  get_cor_plot(downsampled_counts, 'IP_1', 'IP_2'),
		  ncol = 3)
```

##### TPM's

```{r plot_downsampled_tpm_correlations, echo = F, fig.height = 3, fig.width = 10}
plot_grid(get_cor_plot(downsampled_counts, 'IP_3', 'IP_1', quant_type = 'tpm'),
		  get_cor_plot(downsampled_counts, 'IP_3', 'IP_2', quant_type = 'tpm'),
		  get_cor_plot(downsampled_counts, 'IP_1', 'IP_2', quant_type = 'tpm'),
		  ncol = 3)
```

## DE analysis

### Enrichment between pull-downs and input

First we look at enrichments between our pull-downs and the input values, to identify genes which are bound to m6A or IgG (negative control). Lets first compare if we see any differences between IP and IgG.

#### Enrichment of IP vs in IgG

```{r per_sample_enrichment, echo = F}
# calculate ratios of 
enrichment_data <- esat_counts %>%
	calculateEnrichment(conditions = c('IgG', 'IP'), against = 'input')
```

```{r create_big_enrichment_table, echo = F}
big_table <- enrichment_data %>%
	unite('sample', pull_down_condition, replicate) %>%
	dplyr::select(gene_name, sample, tpm_enrichment) %>%
	mutate(sample = paste0(sample, '_enrichment')) %>%
	spread(sample, tpm_enrichment)

# append counts
big_table <- big_table %>%
	inner_join(esat_counts %>%
		 	unite('sample', condition, replicate) %>%
			dplyr::select(gene_name, sample, count) %>%
			#rename sample's before spread
			mutate(sample = paste0(sample, '_count')) %>%
			spread(sample, count),
		by = 'gene_name')

big_table <- big_table %>%
	inner_join(esat_counts %>%
				   unite('sample', condition, replicate) %>%
				   dplyr::select(gene_name, sample, tpm) %>%
				   # rename sample before spread
				   mutate(sample = paste0(sample, '_tpm')) %>%
				   spread(sample, tpm, fill = 0),
			   by = 'gene_name')

write_excel_csv(big_table, paste0(wd, 'data/expression_table.csv'))
```

Next we checked if we indeed get an enrichment in IP/input, versus IgG/input.
This is the case, if we look at the distribution of median enrichment IP/input vs IgG/input: we get more values enriched in the IP/input, and the distribution has a higher mean.

```{r calculate_enrichment_medians, echo = F}
# calculate the median enrichment for both IP/input and IgG/input
enrichment_medians <- enrichment_data %>%
	mutate(condition = pull_down_condition) %>%
	group_by(gene_name, condition) %>%
	summarise(median_enrichment = median(tpm_enrichment)) %>%
	filter(median_enrichment %>% is.finite)
```

```{r plot_density_of_enrichment_hist, echo = F}
# calculate mean of each distribution, for later visualisation
mu <- enrichment_medians %>%
	ungroup %>%
	group_by(condition) %>%
	summarise(grp.mean = mean(median_enrichment))

# visualise enrichment, plotting also the means
enrichment_medians %>%
	mutate(condition = factor(condition, levels = c('IgG', 'input', 'IP'))) %>%	
	ggplot(aes(median_enrichment, color = condition, fill = condition)) +
		geom_density(alpha = 0.3) +
		geom_vline(data = mu, aes(xintercept = grp.mean, color = condition), size = 1, linetype='dashed') +
		scale_fill_manual(values=wes_palette(n=3, name="GrandBudapest1")) +
		scale_color_manual(values=wes_palette(n=3, name="GrandBudapest1")) +
		scale_x_continuous(breaks = 0:5, limits = c(0, 5.5)) +
		ggtitle('Median enrichment of IP and IgG versus input')
```

```{r plot_density_of_enrichment_points, echo = F, eval = F}
enrichment_medians %>%
	spread(condition, median_enrichment) %>%
	ggplot(aes(IP, IgG)) +
		geom_point()
```

#### Enrichment between downsampled and normal IP's

```{r compare_enrichment_downsampled_normal, echo = F}
# combine dowsnapled enrichment with normal enrichment. 
# basically this means that the tpm_enrichment will change for IP_3
enrichment_comparison_data <- downsampled_counts %>%
	calculateEnrichment(conditions = c('IgG', 'IP'), against = 'input') %>%
	# select only key columns and tpm
	dplyr::select(replicate, gene_name, pull_down_condition, tpm_enrichment) %>%
	inner_join(enrichment_data %>% dplyr::select(-pull_down_tpm),
			   by = c('replicate', 'gene_name', 'pull_down_condition'),
			   # modify suffix for downregulated and normal enrichment
			   suffix = c('.ds', '.normal')) %>%
	group_by(replicate, pull_down_condition) %>%
	mutate(enrichment_diff = abs(tpm_enrichment.normal - tpm_enrichment.ds))
```

```{r plot_enrichment_difference_density, echo = F}
# plot the enrichment comparison as a density function to get distribution differences
# IP 1 and 2 should stay the same, while IP 3 distribution might slightly change
enrichment_comparison_data %>%
	filter(pull_down_condition == 'IP') %>%
	gather('enrichment_type', 'tpm_enrichment', tpm_enrichment.normal, tpm_enrichment.ds) %>%
	mutate(enrichment_type = factor(enrichment_type),
		   enrichment_type = mapvalues(enrichment_type, from = c('tpm_enrichment.normal', 'tpm_enrichment.ds'), to = c('normal', 'ds')),
		   enrichment_type = factor(enrichment_type, levels = c('normal', 'ds')), 
		   tpm_enrichment = log10(tpm_enrichment)) %>% 
	filter(tpm_enrichment %>% is.finite) %>%
	ggplot(aes(tpm_enrichment, fill = replicate)) +
		geom_density(alpha = 0.5) +
		facet_wrap(~enrichment_type, labeller = labeller(enrichment_type = c('ds' = 'Downsampled counts', 'normal' = 'Raw counts'))) +
		xlab('log10(tpm_enrichment)') +
		ggtitle('Enrichment of IP vs input', 'Enrichment of IP/input for all 3 replicates')
```

#### Compare the ranks of the enrichment

From the plot above it is clear that IP\_3 is a bit off, as compared to the other two replicates. In order to see if the distributions are similar, we first converted the TPM enrichment values (IP/input) into a rank table, then tested whether the ranks are similar between the conditions with a Kruskal-Wallis test.

```{r compute_enrichment_ranks, echo = F}
enrichment_ranks <- enrichment_data %>%
	# select only IP
	filter(pull_down_condition == 'IP') %>%
	# first filter the data according to input count and pull down tpm
	filter(input_count > 4,  pull_down_tpm > 0.1) %>%
	# prepend IP to each replicate
	mutate(replicate = paste0(pull_down_condition, '_', replicate)) %>%
	# drop some variables
	dplyr::select(-pull_down_tpm, -input, -input_count) %>%
	# spread the tpm enrichment values so that we can filter each which is non finite
	spread(replicate, tpm_enrichment) %>%
	filter(is.finite(IP_1), is.finite(IP_2), is.finite(IP_3)) %>%
	gather('replicate', 'tpm', IP_1:IP_3) %>%
	group_by(replicate) %>%
	# calculate rank: this will be in the opposite order, with rank 1 being the smallest enrichment
	mutate(rank = min_rank(tpm)) %>%
	# convert it correct rank order
	mutate(rank = max(rank) - rank) %>%
	# drop tpm before spreading the data into 3 columns
	dplyr::select(-tpm) %>%
	spread(replicate, rank)
```

The pairwise results are below. It can be seen, that differences between the distributions cannot be established, as the p-values are big. Which makes the samples directly comparable.

```{r perform_wilcox_tests, echo = F}
get_wilcox_res <- function(data, x, y){
	res <- wilcox.test(data[[x]], data[[y]], alternative = 'two.sided')
	res <- data.frame(p.value = res$p.value, data.name = res$data.name)

	res
}

test_res <- enrichment_ranks %>% {
		rbind(
		  get_wilcox_res(., 'IP_1', 'IP_2'),
		  get_wilcox_res(., 'IP_1', 'IP_3'),
		  get_wilcox_res(., 'IP_3', 'IP_2')
		)
	}

test_res$data.name = c('IP_1 vs IP_2', 'IP_1 vs IP_3', 'IP_3 vs IP_2')

kable(test_res)
```

#### Identify consistently enriched candidates

To identify consistently enriched we first filtered the genes as follows:

- The have at least a TPM of 0.1 in all 3 IP's
- They are enriched in all three IP/input comparisons at least 2-fold

```{r identify_enriched_candidates, echo = F}
filtered_data <- enrichment_data %>%
	# filter out IP with tpm <= 0.1
	filter(pull_down_tpm > 0.1 | pull_down_condition == 'IgG') %>%
	# filter genes which have low counts in the input
	filter(input_count > 4) %>%
	# filter NaN, NA, and Inf values
	filter(is.finite(tpm_enrichment)) %>%
	# group by the gene and condition, ie IP or IgG
	group_by(gene_name, pull_down_condition) %>%
	summarise(mean_ip_tpm = mean(pull_down_tpm),
			  median_enrichment = median(tpm_enrichment),
			  max_enrichment = max(tpm_enrichment),
			  min_enrichment = min(tpm_enrichment),
			  passing_filter = n())

# preset variables on which we will filter
filter_ip <- list(mean_tpm = 10,
				  median_enrichment = 3)

# get the significant candidates in IP, that is those which are expressed at least TPM > 0.1 in each IP replicate
candidates_ip <- filtered_data %>%
	filter(passing_filter == 3, pull_down_condition == 'IP') %>%
	mutate(sig = mean_ip_tpm > filter_ip$mean_tpm & median_enrichment > filter_ip$median_enrichment)
```

Below we plot the median TPM enrichment of all 3 IP/input values, against the average IP TPM on a log10-scale.
All values presented here are from after filtering.

Values for which the mean TPM is bigger than `r filter_ip$mean_tpm` and they are at least `r filter_ip$median_enrichment`-fold enriched (in the median) are marked in red.

In total there are `r nrow(filter(candidates_ip, sig ==F))` which pass this filter.

```{r plot_candidate_tpm_vs_enrichment, echo = F}
ip_candidate_plot <- function(candidate_df, filters, plot_title = ''){
	gene.n <- candidate_df %>% nrow
	sig.n <- candidate_df %>% filter(sig == T) %>% nrow

	candidate_df %>%
		ggplot(aes(mean_ip_tpm, median_enrichment)) +
			# first add lines to show what we color red
			# vertical line
			# geom_segment(aes(x = filters$mean_tpm, y = filters$median_enrichment, xend = filters$mean_tpm, yend = Inf),
			# 			 alpha = 0.7,
			# 			 size = 0.1,
			# 			 linetype = 'dashed',
			# 			 color = 'red') +
			# # horizontal line
			# geom_segment(aes(x = filters$mean_tpm, y = filters$median_enrichment, xend = Inf, yend = filters$median_enrichment),
			# 			 alpha = 0.7,
			# 			 size =0.1,
			# 			 linetype = 'dashed',
			# 			 color = 'red') +
			# annotate("text", Inf, Inf, label = paste0(sig.n, '/',gene.n, ' genes'), hjust = 2, vjust = 15) +
			geom_point(size = 0.8, alpha = 0.7) +
			scale_y_continuous(breaks = 2:10) +
			scale_x_log10(breaks = c(1,10,100,1000,10000)) +
			scale_color_manual(values = c('black', 'red')) +
			annotation_logticks(sides = 'b') +
			labs(y = 'Median TPM enrichment of m6A/input', x = 'Mean of IP TPM\'s') +
			theme(legend.position = 'none') +
			ggtitle(plot_title) 
}

candidates_ip %>%
	ip_candidate_plot(plot_title = 'Enriched genes IP/input', filters = filter_ip)
```

In total there are `r nrow(filter(candidates_ip, sig == T))`/`r nrow(filter(candidates_ip, sig ==F))` genes which have mean TPM of at least 10, and average enrichment of at least 4.

#### Remove the background coming from IgG pull-down

```{r candidate_igg_background_removal, echo = F}
# define candidate differences: between IP and IgG
enrichment_diff <- filtered_data %>%
	ungroup() %>%
	# only get genes which pass the filter, set above 
	filter(passing_filter == 3 | pull_down_condition == 'IgG') %>%
	transmute(gene_name = gene_name,
			  condition = pull_down_condition,
			  # select the highest IgG enrichment vs lowest IP
			  selected_enrichment = ifelse(condition == 'IP', median_enrichment, median_enrichment)) %>%
	# spread enrichment ratios
	spread(condition, selected_enrichment) %>%
	# calculate the difference between IP and IgG
	mutate(enrichment_diff = IP - IgG) %>%
	filter(is.finite(enrichment_diff))
```

```{r plot_candidate_tpm_vs_enrichment_diff_igg, echo = F}
# we plot the same plot as above, but this time only using the genes for which there is a difference between IP and IgG enrichment
candidates_ip_diff <- candidates_ip %>%
	# show only candidates, for which IP enrichment is bigger than 0
	filter(gene_name %in% (enrichment_diff %>% filter(enrichment_diff > 2) %$% gene_name))

candidates_ip_diff %>%
	ip_candidate_plot(plot_title = 'Enriched genes IP/input without IgG background', filters = filter_ip)
```

Here in total there are `r nrow(filter(candidates_ip_diff, sig == T))`/`r nrow(filter(candidates_ip_diff, sig ==F))` genes which have mean TPM of at least 10, and average enrichment of at least 4.


#### Comparing enrichment IP vs IgG

```{r plot_igg_vs_ip_enrichment, echo = F}
pl_in <- enrichment_diff %>%
	mutate(sig = enrichment_diff > 2)

pl_in %>%
	ggplot(aes(IP, IgG, color = sig)) +
		geom_point(size = 0.9, alpha = 0.7) +
		scale_y_continuous(breaks = 0:10, limits = c(0,10)) +
		scale_x_continuous(breaks = 0:10, limits = c(0,10)) +
		scale_color_manual(values = c('black', 'red')) +
		coord_fixed() +
		theme(legend.position = 'none') +
		labs(x = 'median(m6A/input)', y = 'median(IgG/input)') +
		ggtitle('IP vs IgG enrichment', '(IP - IgG)/input > 2 in red')
```

```{r get_genome_and_gtf, echo = F}
library(BSgenome)
library(GenomicFeatures)

txdb <- makeTxDbFromGFF(paste0(wd, '../../shared/annotations/dm6.gtf'))
dm6_genome <- readDNAStringSet(paste0(wd, '../../shared/genomes/dm6.fa')) 

# rename the chr names, as in the original dm6.fasta they have have some stuff appended after 2L, etc
names(dm6_genome) <- names(dm6_genome) %>%
	tibble(names = .) %>%
	separate(names, into = c('chr'), extra = 'drop')  %$%
	chr

gene_exons <- exonsBy(txdb, by = 'gene') %>%
	# collapse the ranges, so that overlapping exons are joined together
	reduce() %>%
	# get the data to tibble
	as_tibble %>%
	# filter for only cannonical chromosomes
	filter(seqnames %in% c('3R', '2R', '3L', '2L', 'X', 'Y', '4')) %>%
	makeGRangesListFromDataFrame(split.field = 'group_name')
```

```{r get_sequences, echo = F}
gene_sequences <- llply(gene_exons, function(gene){
	chr <- gene[1] %>% seqnames %>% as.character
	strand <- gene[1] %>% strand %>% as.character

	# get the sequences from a given chromosome, between the exon starts and ends
	sequence <- extractAt(dm6_genome[[chr]], at = ranges(gene))

	# join ranges together
	sequence <- unlist(sequence)

	# if reverse strand, take the reverse complement
	if(strand == '-'){
		sequence <- reverseComplement(sequence)
	}

	return(sequence)
}) %>%
DNAStringSet
```

```{r save_sequences, echo = F}
candidate_gene_names <- enrichment_diff %>%
	filter(enrichment_diff > 2) %$%
	gene_name

# get esat counts, and filter only the IP's, and get the median of those
counts_for_fasta <- esat_counts %>%
	filter(condition == 'IP') %>%
	group_by(gene_id) %>%
	summarise(tpm = median(tpm))

# flag candidates, join original gene tibble together, to account for dropouts
counts_for_fasta <- genes %>%
	# flag the candidates in the original gene table
	mutate(is_candidate = gene_name %in% candidate_gene_names) %>%
	# join the median tpm counts for IP
	left_join(counts_for_fasta, by = 'gene_id') %>%
	# create names for the fasta output, which contain tpm-s attached to the gene name
	mutate(tpm = ifelse(is.na(tpm), 0, tpm),
		   fasta_name = paste0(gene_id, ' ', tpm)) %>%
	# take only genes for which we have sequences
	filter(gene_id %in% names(gene_sequences))

# we don't need this, as we compare candidates to rest...
candidate_seq <- gene_sequences[counts_for_fasta %>% filter(is_candidate) %$% gene_id]
#names(candidate_seq) <- counts_for_fasta %>% filter(gene_id %in% names(candidate_seq)) %$% fasta_name

rest_seq <- gene_sequences[counts_for_fasta %>% filter(!is_candidate) %$% gene_id]
#names(rest_seq) <- counts_for_fasta %>% filter(gene_id %in% names(rest_seq)) %$% fasta_name

writeXStringSet(candidate_seq,
				paste0(wd, 'data/candidates/candidates.fa'))

writeXStringSet(rest_seq,
				paste0(wd, 'data/candidates/control_seqs.fa'))
```

### Differential expression: building a DESeq2 model

First we build a DEseq model on the data for IP vs input and IP vs IgG. We build a paired model using the formula  `~ replicate + condition` to account for variability between replicates.

```{r prepare_deseq, echo = F}
m6a_dds <- DESeq(m6a_dds)

ip_vs_input.res <- results(m6a_dds,name = 'condition_IP_vs_input', alpha = 0.01)
ip_vs_input.resLFC <- lfcShrink(m6a_dds, res = ip_vs_input.res, coef = 'condition_IP_vs_input', type = 'apeglm') %>%
	as.data.frame %>%
	rownames_to_column(var = 'gene_name') %>%
	as_tibble
```


```{r plot_volcano_plot, echo = F}
ip_vs_input.resLFC %>%
	filter(!is.na(padj)) %>%
	mutate(sig = ifelse(log2FoldChange > log2(3) & padj < 0.01, T, F)) %>%
	ggplot(aes(log2FoldChange, -log10(padj))) +
		geom_point(aes(color = sig), alpha = 0.7, size = 0.8) + 
		xlim(-3.5, 3.5) +
		scale_color_manual(values = c('black', 'red')) +
		ggtitle('Several genes highly enriched IP vs input',
				'Genes with LFC > 3 and adjusted p < 0.01 colored in red') +
		theme(legend.position = 'none')
```

## Uniting with data from RFP (Nagarjuna 2017)

```{r read_fc_output, echo = F}
rfp_fc <- readRDS(paste0(wd, '../../nagarjuna/rfp/data/counts/feature_counts.rds'))

colnames(rfp_fc$counts) <- c('ld_1', 'ld_2', 'hd_1', 'hd_2')

rfp_counts <- rfp_fc$counts %>%
	as.data.frame

rfp_counts <- rfp_counts %>%
	rownames_to_column(var = 'gene_id') %>%
	as_tibble %>%
	separate(gene_id, into = c('gene_id'), extra = 'drop')

# get gene names from the counts which are not in biomart genes
n <- rfp_counts %>%
	filter(!(gene_id %in% genes$gene_id)) %$%
	gene_id

# we can get these names and convert them to their current symbols using: https://flybase.org/convert/id
# the output is saved to ../../data/FlyBase_IDs.txt

# get only ones which really changed
convert_ids <- read_table2(paste0(wd, 'data/FlyBase_IDs.txt')) %>%
	filter(submitted_id != current_id) %>%
	dplyr::rename(gene_id = submitted_id) %>%
	dplyr::select(gene_id, converted_id)

# update the gene_ids
rfp_counts <- rfp_counts %>%
	left_join(convert_ids, by = 'gene_id') %>%
	# if convert id exists
	mutate(gene_id = ifelse(is.na(converted_id), gene_id, converted_id)) %>%
	dplyr::select(-converted_id)

# use inner join as all the id should be updated by now
rfp_counts <- rfp_counts %>%
	inner_join(genes, by = 'gene_id') %>%
	filter(!(gene_biotype %in% c('rRNA', 'tRNA', 'snRNA', 'snoRNA')))
```

```{r calculate_fc_tpm, echo = F}
rfp_tpm <- rfp_counts %>%
	gather('experiment', 'count', ld_1:hd_2) %>%
	group_by(experiment) %>%
	mutate(tpm = count / gene_length,
		   tpm = tpm / sum(tpm) * 1e6) %>%
	dplyr::select(-count) %>%
	spread(experiment, tpm)
```

```{r create_deseq_rfp, echo = F}
rfp_metadata <- data.frame(condition = factor(c('ld', 'ld', 'hd', 'hd'), levels = c('ld', 'hd')),
						   replicate = c(1,2,1,2),
						   row.names = c('ld_1', 'ld_2', 'hd_1', 'hd_2'))

dds <- DESeqDataSetFromMatrix(as.matrix(rfp_fc$counts),
							  colData = rfp_metadata,
							  design = ~condition)

dds <- DESeq(dds) 

res <- results(dds, alpha = 0.01)
resLFC <- lfcShrink(dds = dds, res = res, coef = 'condition_hd_vs_ld') %>%
	data.frame %>%
	rownames_to_column(var = 'gene_id') %>%
	as_tibble %>%
	left_join(genes, by = 'gene_id')
```

```{r plot_enriched_genes_tpm_by_rank, echo = F, fig.width = 10, fig.height = 7}
library(mgcv)
sig_genes_up <- resLFC %>%
	filter(log2FoldChange > 1, padj < 0.01) %$%
	gene_id

rfp_tpm_ranked <- rfp_tpm %>%
	filter(gene_id %in% sig_genes_up) %>%
	arrange(desc(hd_1 + hd_2 - ld_1 - ld_2)) %>%
	mutate(rank = 1:n()) 

rfp_tpm_ranked %>%
	filter(gene_id %in% sig_genes_up) %>%
	gather('experiment', 'tpm', c('ld_1', 'ld_2', 'hd_1', 'hd_2')) %>%
	separate('experiment', into = c('condition', 'replicate')) %>%
	ggplot(aes(rank, tpm, color = condition)) +
		geom_smooth(aes(linetype=replicate)) + 
		geom_point(size = 0.7, alpha = 0.5) +
		geom_rug(sides = 'l', alpha=0.1, position = 'jitter') +
		scale_color_manual(values=wes_palette(n=2, name="Darjeeling1")) +
		scale_y_log10()
```

```{r plot_enriched_genes_tpm_density, echo =F}
rfp_tpm_ranked %>%
	gather('experiment', 'tpm', c('ld_1', 'ld_2', 'hd_1', 'hd_2')) %>%
	separate('experiment', into = c('condition', 'replicate')) %>%
	mutate(log_tpm = log10(tpm)) %>%
	filter(gene_biotype == 'protein_coding') %>%
	ggplot(aes(log_tpm, fill = condition)) +
		geom_density(alpha = 0.7)+
		scale_fill_manual(values=wes_palette(n=2, name="Darjeeling1"))


rfp_tpm_ranked %>%
	gather('experiment', 'tpm', c('ld_1', 'ld_2', 'hd_1', 'hd_2')) %>%
	separate('experiment', into = c('condition', 'replicate')) %>%
	filter(condition == 'hd', tpm > 100) %$%
	gene_biotype %>%
	table
```

```{r plot_ld_vs_hd_tpm, echo = F}
rfp_tpm_ranked %>%
	filter(gene_id %in% sig_genes_up) %>%
	mutate(ld = log10((ld_1 + ld_2) / 2),
		   hd = log10((hd_1 + hd_2) / 2)) %>%
	ggplot(aes(hd, ld)) +
		geom_point(aes(color = (hd - ld) > 1)) +
		coord_fixed()
```


### Volcano plot of LD vs HD

```{r plot_ld_vs_hd_volcano, echo = F}
resLFC %>%
	mutate(neg_log10_p = -1 * log10(padj)) %>%
	ggplot(aes(log2FoldChange, neg_log10_p)) +
		geom_point(alpha = 0.5, size = 1)
```

---
# Kallisto

Second, we also calculated the transcript counts with using kallisto (ref needed). This, instead of mapping the reads creates pseudo-counts with building a probabilistic model.
---

```{r load_kallisto_results, echo = F, eval=F}
####
# import kallisto using read_table2
####
kallisto_dir = paste0(wd, 'data/kallisto_quant/')

kallisto_data <- samples %>% ldply(function(smpl){
		df <- read_table2(paste0(kallisto_dir, '/', smpl, '/abundance.tsv'))
		df$sample <- smpl

		df
	}) %>% 
	as_tibble %>%
	separate(sample, into = c('condition', 'replicate'), sep = '[_]') %>%
	dplyr::rename(tx_id = target_id) %>%
	mutate(tx_id = as.factor(tx_id),
		   condition = as.factor(condition)) %>%
	left_join(txs, by = 'tx_id')

####
# import kallisto with tximport
###

tx2gene <- txs %>%
	transmute(TXNAME = tx_id,
			  GENEID = gene_id)

kallisto_metadata <- tibble(sample = samples) %>%
	separate(sample, into = c('condition', 'replicate', 'rnd'), remove = F) %>%
	# remove randomly generated suffix
	dplyr::select(-rnd) %>%
	mutate(path = paste0(kallisto_dir, sample),
		   condition = factor(condition, levels = c('input', 'IgG', 'IP'))) %>%
	# sort tibble by factor
	arrange(condition)

txi <- kallisto_metadata %>%
	mutate(files = paste0(path, '/abundance.tsv')) %>%
	{
		files <- .$files
		names(files) <- .$sample 
		tximport(files, type = 'kallisto', tx2gene = tx2gene, ignoreAfterBar = T)
	}

dds <- DESeqDataSetFromTximport(txi, as.data.frame(kallisto_metadata), ~condition + replicate)

# create kallisto counts from txi on the gene level (together with tpm's)
kallisto_gene_counts <- txi$counts %>% 
	# get counts and load them as dataframe
	as.data.frame %>%
	# convert rownames to a column
	rownames_to_column(var = 'gene_id') %>%
	# convert to tibble
	as_tibble %>%
	# join with metadata about genes and txs
	left_join(genes, by = 'gene_id') %>%
	# create column for run and counts
	gather('run', 'count', samples) %>%
	# separate the run column and drop random overhang
	separate(run, into = c('condition', 'replicate'), extra = 'drop') %>%
	# group by condition and replicate
	group_by(condition, replicate) %>%
	# calculate tpm
	mutate(tpm = count / gene_length,
		   tpm = tpm / sum(tpm) * 1e6)
```

```{r create_combined_data, echo = F, eval = F}

```

```{r calculate_count_correlation_esat_kallisto, echo = F, eval = F}
kallisto_vs_esat <- ddply(combined_counts, .(condition, replicate), function(tb){
	data.frame(correlation = cor(tb$count, tb$esat_count))
})

kallisto_vs_esat %>% kable
```

```{r plot_kallisto_vs_esat, echo = F, eval = F}
combined_counts %>%
	rename(count = 'kallisto_count') %>%
	ggplot(aes(kallisto_count, esat_count)) +
		geom_point() +
		scale_y_log10() +
		scale_x_log10() +
		facet_grid(condition ~ replicate)
```
