--- 
title: "m6a analysis"
author: "tsztank"
date: "`r format(Sys.time(), '%d/%B/%Y')`"
output: 
  html_document:
    theme: journal
---

```{r knitr_options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  cache = T,
  autodep = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = NA,
  cache.path = 'cache/',
  fig.path = 'figures/',
  knitr.table.format = 'markdown')
```

```{r load_libraries, echo = F, cache = F}
library(plyr)
library(tidyverse)
library(biomaRt)
library(magrittr)
library(yaml)
library(readr)
library(cowplot)
library(wesanderson)
library(GGally)
library(DESeq2)
library(tximport)
library(kableExtra)
```

```{r load_functions, echo = F, cache = F}
source('readStarLog.R')
```

```{r get_gene_name_id_map, echo = F}
ensembl = useMart('ensembl', dataset = 'dmelanogaster_gene_ensembl')

txs <- ensembl %>%
	getBM(
		  attributes = c('ensembl_gene_id',
						 'ensembl_transcript_id',
						 'external_gene_name',
						 'external_transcript_name',
						 'start_position', 
						 'end_position', 
						 'strand'),
		  mart = .) %>%
	as_tibble

colnames(txs) <- c('gene_id', 'tx_id', 'gene_name', 'tx_name', 'gene_start', 'gene_end', 'strand') 

txs <- txs %>% mutate(gene_length = gene_end - gene_start)

genes <- txs %>%
	dplyr::select(-tx_id, -tx_name) %>%
	unique %>%
	mutate(gene_length = gene_end - gene_start)
```

```{r load_sample_specification, echo = F}
config = read_yaml('../../config.yaml')
samples <- config$samples
```

# Initials checks

TODO: load star here, and fastqc

# Analysis

ESAT (ref) is a counting toolkit designed for short 3' or 5' libraries. As a check, we also mapped the reads with STAR and then counted the reads on the gene level with ESAT, and correlated the results with counts coming from kallisto+tximport

## Sanity checks

The if we plot the counts and tpm-s (transcript per million) on a log-x scale, we observe a normal distribution which is expected. Also, the mean values of tpm-s are comparable, so it seems there is not big difference between the libraries of the 3 conditions sequenced.

```{r import_esat_counts, echo = F}

esat_dir = '../../data/esat/'
esat_counts <- samples %>%
	# create a dataframe out of counts
	data.frame(sample = .) %>%
	# create a filename column, and load dataframes as a list
	mutate(filename = paste0(esat_dir, sample, '.gene.txt'), 
		   file_contents = map(filename, ~read_table2(.))) %>%
	# expand the lists
	unnest() %>%
	# create tibble
	as_tibble %>%
	# rename columns
	transmute(sample = sample,
			  gene_id = Symbol,
			  count = Exp1) %>%
	# fill non detected genes in each sample with zeros
	spread(sample, count, fill = 0) %>%
	# gather back
	gather('sample', 'count', samples) %>%
	separate(sample, into = c('condition', 'replicate'), extra = 'drop') %>%
	inner_join(genes, by = 'gene_id') %>%
	mutate(tpm = count / gene_length,
		   tpm = tpm / sum(tpm) * 1e6)
```

```{r plot_histogram_tpm, echo =F}
esat_counts %>%
	ggplot(aes(tpm, fill = condition)) +
	geom_density(alpha = 0.8) +
	scale_x_log10() +
	scale_fill_manual(values=wes_palette(n=3, name="GrandBudapest1")) +
	ggtitle('TPM comparison between conditions')
```

```{r plot_histogram_counts, echo =F}
esat_counts %>%
	ggplot(aes(count, fill = condition)) +
	geom_density(alpha = 0.8) +
	scale_x_log10() +
	scale_fill_manual(values=wes_palette(n=3, name="GrandBudapest1")) +
	facet_grid(condition~replicate) +
	theme(axis.text.x = element_text(angle = 45, hjust =1)) +
	ggtitle('Estimated counts of each run')
```

## PCA analysis

```{r create_dds_from_counts, echo = F}
sample_metadata <- tibble(sample = samples) %>%
	separate(sample, into = c('condition', 'replicate'), extra = 'drop') %>%
	unite('sample', condition, replicate, remove =F) %>%
	mutate(condition = factor(condition, levels = c('input', 'IgG', 'IP')),
		   replicate = factor(replicate, levels = c('1','2','3'))) %>%
	# sort tibble by factor
	arrange(condition)

count_matrix <- esat_counts %>%
	unite('sample', c('condition', 'replicate')) %>%
	dplyr::select(sample, count, gene_name) %>%
	# spread values, fill with 0, as NA here means ND = 0 count
	spread(sample, count, fill = 0) %>%
	{
		genes <- .$gene_name
		mx <- dplyr::select(., -gene_name) %>%
			as.matrix

		rownames(mx) <- genes

		mx
	}

# get the columns into the right order
count_matrix <- count_matrix[,sample_metadata$sample]

dds <- DESeqDataSetFromMatrix(countData = count_matrix,
							  colData = sample_metadata %>% {data.frame(., row.names = .$sample)},
							  design = ~ replicate + condition )
```

From the below PCA plot we can clearly see, that replicate 3 is an outlier, it is therefore probably better to not take it into account.

```{r pca_analysis, echo = F}
vsd <- vst(dds, blind=FALSE)
pca <- plotPCA(vsd, intgroup=c('condition', 'replicate'), returnData=T) %>%
	as_tibble

pca %>%
	# modify factor level to have consistent colors
	mutate(condition = factor(condition, levels = c('IgG', 'input', 'IP'))) %>%
	ggplot(aes(PC1, PC2, colour = condition, shape = replicate)) + 
	geom_point(size = 4) +
	scale_colour_manual(values=wes_palette(n=3, name="GrandBudapest1"))

```

## Looking at genes of interest

First lets look at 3 genes: Clk, tim and vri.

It seems that for these 3 genes, IgG\_3 is an outlier.

```{r plot_genes_of_interest, echo = F, fig.width = 10, fig.height = 5}
genes_of_interest <- c('vri', 'Clk', 'tim')

plot_genes <- function(tpm, genes, x_lab, metric = 'tpm'){
	tpm %>%
		filter(gene_name %in% genes) %>%
		ggplot(aes_string(x_lab, metric, colour = 'condition', shape = 'replicate')) +
			geom_point(size = 4, position = position_dodge(width=0.3)) +
			scale_colour_manual(values=wes_palette(n=3, name="GrandBudapest1")) +
			scale_y_log10()
}

pl1 <- plot_genes(esat_counts, genes_of_interest, x_lab = 'gene_name', metric = 'tpm')
pl2 <- plot_genes(esat_counts, genes_of_interest, x_lab = 'gene_name', metric = 'count')

plot_grid(pl1, pl2, ncol = 2)
```

Lets look at Mbl separately. Here we again can observe that 3 is an outlier compared to others.

```{r plot_mbl_tpm, echo = F}
plot_genes(esat_counts, c('mbl'), x_lab = 'gene_name', metric = 'tpm')
```

## Correlation between replicates

```{r plot_correlation_between_replicates, echo = F, fig.height = 3, fig.width = 10}
get_cor_plot <- function(data, sx, sy, quant_type = 'count'){
	dat <- data %>%
		unite('run', condition, replicate) %>%
		dplyr::select(gene_id, run, quant_type) %>%
		spread(run, quant_type, fill = 0)

	r <- cor(dat[[sx]], dat[[sy]])

	pl <- dat %>%
		# convert quant_type to log for visualization
		gather('run', 'quant_type', -gene_id) %>%
		mutate(quant_type = log10(quant_type)) %>%
		spread(run, quant_type) %>%
		ggplot(aes_string(x=sx, y=sy)) +
			geom_point(alpha = 0.8, size = 0.5) +
			coord_fixed()

	pl <- pl + annotate("text", Inf, -Inf, label = paste0('R = ', round(r, 3)), hjust = 1, vjust = -5)

	pl
}

plot_grid(get_cor_plot(esat_counts, 'IP_1', 'IP_3'),
		  get_cor_plot(esat_counts, 'IP_2', 'IP_3'),
		  get_cor_plot(esat_counts, 'IP_1', 'IP_2'),
		  ncol = 3)
```

## DE analysis

### Deseq model

First we build a DEseq model on the data for IP vs input and IP vs IgG. We build a paired model using the formula  `~ replicate + condition` to account for variability between replicates.

```{r prepare_deseq, echo = F}
dds <- DESeq(dds)

ip_vs_input.res <- results(dds, name = 'condition_IP_vs_input', alpha = 0.01)
ip_vs_input.resLFC <- lfcShrink(dds, res = ip_vs_input.res, coef = 'condition_IP_vs_input', type = 'apeglm')
```


```{r plot_volcano_plot, echo = F}
ip_vs_input.resLFC %>%
	as.data.frame %>%
	rownames_to_column(var = 'gene_name') %>%
	as_tibble %>%
	filter(!is.na(padj)) %>%
	mutate(sig = ifelse(log2FoldChange > log2(3) & padj < 0.01, T, F)) %>%
	ggplot(aes(log2FoldChange, -log10(padj))) +
		geom_point(aes(color = sig), alpha = 0.7, size = 0.8) + 
		xlim(-3.5, 3.5) +
		scale_color_manual(values = c('black', 'red')) +
		ggtitle('Several genes highly enriched IP vs input',
				'Genes with LFC > 3 and adjusted p < 0.0 colored in red') +
		theme(legend.position = 'none')
```

### Compare enrichment on a per-sample basis

```{r per_sample_enrichment, echo = F}
# calculate ratios of 
enrichment_data <- esat_counts %>%
	dplyr::select(condition, replicate, gene_id, gene_name, tpm) %>%
	# spread the tpm-s across conditions
	spread(condition, tpm) %>%
	# group tpm's back into one column, this time only IgG and IP
	gather('pull_down_condition', 'pull_down_tpm', c('IgG', 'IP')) %>%
	group_by(pull_down_condition, replicate) %>%
	mutate(tpm_enrichment = pull_down_tpm / input)
```

```{r create_big_enrichment_table, echo = F}
big_table <- enrichment_data %>%
	unite('sample', pull_down_condition, replicate) %>%
	dplyr::select(gene_name, sample, tpm_enrichment) %>%
	mutate(sample = paste0(sample, '_enrichment')) %>%
	spread(sample, tpm_enrichment)

# append counts
big_table <- big_table %>%
	inner_join(esat_counts %>%
		 	unite('sample', condition, replicate) %>%
			dplyr::select(gene_name, sample, count) %>%
			#rename sample's before spread
			mutate(sample = paste0(sample, '_count')) %>%
			spread(sample, count),
		by = 'gene_name')

big_table <- big_table %>%
	inner_join(esat_counts %>%
				   unite('sample', condition, replicate) %>%
				   dplyr::select(gene_name, sample, tpm) %>%
				   # rename sample before spread
				   mutate(sample = paste0(sample, '_tpm')) %>%
				   spread(sample, tpm, fill = 0),
			   by = 'gene_name')

write_excel_csv(big_table, '../../data/expression_table.csv')
```


```{r calculate_enrichment_medians, echo = F}
enrichment_medians <- enrichment_data %>%
	mutate(condition = pull_down_condition) %>%
	group_by(gene_name, condition) %>%
	summarise(median_enrichment = median(tpm_enrichment))
```

```{r plot_density_of_enrichment_hist, echo = F}
enrichment_medians %>%
	mutate(condition = factor(condition, levels = c('IgG', 'input', 'IP'))) %>%	
	ggplot(aes(median_enrichment, fill = condition)) +
		geom_density(alpha = 0.8) +
		scale_fill_manual(values=wes_palette(n=3, name="GrandBudapest1")) +
		scale_x_continuous(breaks = 0:5, limits = c(0, 5.5)) +
		ggtitle('Median enrichment of IP and IgG versus input')
```

```{r plot_density_of_enrichment_points, echo = F}
enrichment_medians %>%
	spread(condition, median_enrichment) %>%
	ggplot(aes(IP, IgG)) +
		geom_point()
```

---
# Kallisto

Second, we also calculated the transcript counts with using kallisto (ref needed). This, instead of mapping the reads creates pseudo-counts with building a probabilistic model.
---

```{r load_kallisto_results, echo = F, eval=F}
####
# import kallisto using read_table2
####
kallisto_dir = '../../data/kallisto_quant/'

kallisto_data <- samples %>% ldply(function(smpl){
		df <- read_table2(paste0(kallisto_dir, '/', smpl, '/abundance.tsv'))
		df$sample <- smpl

		df
	}) %>% 
	as_tibble %>%
	separate(sample, into = c('condition', 'replicate'), sep = '[_]') %>%
	dplyr::rename(tx_id = target_id) %>%
	mutate(tx_id = as.factor(tx_id),
		   condition = as.factor(condition)) %>%
	left_join(txs, by = 'tx_id')

####
# import kallisto with tximport
###

tx2gene <- txs %>%
	transmute(TXNAME = tx_id,
			  GENEID = gene_id)

kallisto_metadata <- tibble(sample = samples) %>%
	separate(sample, into = c('condition', 'replicate', 'rnd'), remove = F) %>%
	# remove randomly generated suffix
	dplyr::select(-rnd) %>%
	mutate(path = paste0(kallisto_dir, sample),
		   condition = factor(condition, levels = c('input', 'IgG', 'IP'))) %>%
	# sort tibble by factor
	arrange(condition)

txi <- kallisto_metadata %>%
	mutate(files = paste0(path, '/abundance.tsv')) %>%
	{
		files <- .$files
		names(files) <- .$sample 
		tximport(files, type = 'kallisto', tx2gene = tx2gene, ignoreAfterBar = T)
	}

dds <- DESeqDataSetFromTximport(txi, as.data.frame(kallisto_metadata), ~condition + replicate)

# create kallisto counts from txi on the gene level (together with tpm's)
kallisto_gene_counts <- txi$counts %>% 
	# get counts and load them as dataframe
	as.data.frame %>%
	# convert rownames to a column
	rownames_to_column(var = 'gene_id') %>%
	# convert to tibble
	as_tibble %>%
	# join with metadata about genes and txs
	left_join(genes, by = 'gene_id') %>%
	# create column for run and counts
	gather('run', 'count', samples) %>%
	# separate the run column and drop random overhang
	separate(run, into = c('condition', 'replicate'), extra = 'drop') %>%
	# group by condition and replicate
	group_by(condition, replicate) %>%
	# calculate tpm
	mutate(tpm = count / gene_length,
		   tpm = tpm / sum(tpm) * 1e6)
```

```{r create_combined_data, echo = F, eval = F}

```

```{r calculate_count_correlation_esat_kallisto, echo = F, eval = F}
kallisto_vs_esat <- ddply(combined_counts, .(condition, replicate), function(tb){
	data.frame(correlation = cor(tb$count, tb$esat_count))
})

kallisto_vs_esat %>% kable
```

```{r plot_kallisto_vs_esat, echo = F, eval = F}
combined_counts %>%
	rename(count = 'kallisto_count') %>%
	ggplot(aes(kallisto_count, esat_count)) +
		geom_point() +
		scale_y_log10() +
		scale_x_log10() +
		facet_grid(condition ~ replicate)
```
